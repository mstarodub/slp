commit f0ab0346854ae67cd55c9e1c4542caba50153107
Author: mxs <mxs@dismail.de>
Date:   Fri Sep 22 23:16:32 2023 +0200

    big refactor

diff --git a/src/demo_doc.pl b/src/demo_doc.pl
index 40f82c7..dca900a 100644
--- a/src/demo_doc.pl
+++ b/src/demo_doc.pl
@@ -1,15 +1,23 @@
 % TODO
-% M constrained sampling
-% ? bringing pack p/3 implementation for free query input (e.g. probs differ for t(X, X) and t(X,Y) on calling t(a,a) if clause t(a, g) exists)
-% ? motivate p/3 with a test case
+% M take another look at substit_rec, unifset_rec - why does unifset_rec unification never happen but for true = true?
+% M remove writeln calls
+% M sample_UC sometimes errors for compound:
+%   sample_UC((s(X,Y), r(Y,Z))).
+% M sample_SC always errors for compound:
+%   sample_SC((s(X,Y), r(Y,Z))).
+% M sample_SC/UC(s(X,Y)). sometimes errors
+% M test sample_SC for nonground + ground with arity >= 1
+% M sample_SC may need cuts
+% ? BUG: p(cmp1(b), P). -> zero divisor
+% ? twice repeated output of P=1 for inference_SC_test(dq(a),P).
+% ? no backtracking for inference_SC(cmp(X),P). (however, backtracking for G = s(X,Y), r(Y,Z) works...)
+% ? bringing back p/3 implementation for free query input (e.g. probs differ for t(X, X) and t(X,Y) on calling t(a,a) if clause t(a, g) exists)
+%   + motivate p/3 with a test case
 % ? backtracking for inference: test functionality scope of current implementation
 % R demo / tests
-% M cuts
-% M code organisation / refactor
-% ? can sampling(G) call (for G either true or fail) be integrated in other cases? (both sampling_UC and sampling_SC)
-% M compound assert/retract inference_SC
 % M err if a functor's labels sum to >1'
-% M special sampling mit SC inference
+% M sampling/inference (SC, UC): uniform output for goals that don't exist
+% M special sampling with SC inference
 
 % - nested functors: st(dqq(X)) : inference, sampling
 % - impure
diff --git a/src/slp.pl b/src/slp.pl
index d13ec09..d168d11 100644
--- a/src/slp.pl
+++ b/src/slp.pl
@@ -2,17 +2,78 @@
 :- discontiguous (::)/2.
 :- dynamic (::)/2.
 
-% meta-assumptions:
+% assumptions:
 %   only conjunctions
 %   normalized SLP (all clauses forming a predicate add up to 1)
 %   pure SLP (no non-prob. clauses)
 
+% used for propagating bindings of CurrentGoal to RemainingGoal
+% takes List in the form [X=a, Y=b, ...]
+% TODO: should be this ideally, but issues in e.g. unifSet_rec
+% unify_list(_, []) :- !.
+% unify_list(Term, [Var=Binding|BagTail]) :-
+%     Var=Binding,
+%     unify_list(Term, BagTail).
+% https://stackoverflow.com/a/64722773
+unify_list(_, []) :- !.
+unify_list(Term, [Var=Binding|BagTail]) :-
+    findall(Term, Var=Binding, [Term]),
+    unify_list(Term, BagTail).
 
-% transferring initial goal to list
+% other predicates analyzing and replacing (sub)terms operate on lists
+% rewrites conjuncts to elements
 goal_to_list((G1, G2), [G1|GoalTail]) :- goal_to_list(G2, GoalTail).
 goal_to_list(G, [G]) :- G \= (_ , _).
 
-% forcing backtracking over possible bindings for free variables in Goal
+% collects all bindings / ground atoms
+collect_grounds(Term, GroundList) :-
+    (   nonvar(Term)
+    ->  Term =.. [X|Args],
+        (   Args = []
+        ->  GroundList = [X]
+        ;   % concatmap
+            maplist(collect_grounds, Args, Nested),
+            flatten(Nested, GroundList)
+        )
+    ;   GroundList = []
+    ).
+
+% used for replacing ground atoms with variables
+replace(Replacee, Replacement, Term, Res) :-
+    (   Term == Replacee
+    % base case - ground atom
+    ->  Res = Replacement
+    ;   (   var(Term)
+        % preserve variable
+        ->  Res = Term
+        % functor case - separate the arguments and recur
+        ;   Term =.. [F|Args0],
+            maplist(replace(Replacee, Replacement), Args0, Args),
+            % reassemble
+            Res =.. [F|Args]
+        )
+    ).
+
+replace_grounds(Term, [], [], Term).
+replace_grounds(Term, [GroundHead|GroundTail], [VarHead|VarTail], FreeTerm) :-
+    replace(GroundHead, VarHead, Term, ReplacedTerm),
+    % replaced (Res) becomes new replacee
+    replace_grounds(ReplacedTerm, GroundTail, VarTail, FreeTerm).
+
+% need to traverse the goal twice:
+% first - collect all grounds and de-duplicate
+% then - replace them with fresh variables
+free_up_bindings(Goal, FreeGoals) :-
+    collect_grounds(Goal, GroundList),
+    % list_to_set to obtain same variable name for same binding
+    list_to_set(GroundList, GroundSet),
+    % for each ground atom in GroundSet get one fresh free variable
+    length(GroundSet, GroundLength),
+    length(VarSet, GroundLength),
+    % for every distinct ground atom in input goal: replace with free variable
+    replace_grounds(Goal, GroundSet, VarSet, FreeGoals).
+
+% forces backtracking over possible bindings for free variables in goal
 bind_goal([]).
 bind_goal([GoalHead|GoalTail]) :-
     clause((_::GoalHead), _),
@@ -27,7 +88,7 @@ inference_marginal(Goal, ProbRounded) :-
     z(GoalBound, Prob),
     round_third(Prob, ProbRounded).
 
-inference_SC_test(Goal, ProbRounded) :-
+inference_SC(Goal, ProbRounded) :-
     goal_to_list(Goal, GoalList),
     bind_goal(GoalList),
     goal_to_list(GoalBound, GoalList),
@@ -35,251 +96,129 @@ inference_SC_test(Goal, ProbRounded) :-
     ( VarList \= [] -> writeln('true,'); true),
     p(GoalBound, Prob),
     round_third(Prob, ProbRounded).
-    
-inference_SC(G, Prob) :-
-    G \= (_, _),
-    clause(_::G, _),
-    % checking if variables are still free (e.g. X=X), then VarList won't be empty
-    term_variables(G, VarList),
-    ( VarList \= [] -> writeln('true,'); true),
-    p(G, Prob).
-
-% doesnt work for ground goals:
-% inference_SC((q(a), p(a)), P).
-inference_SC((G1,G2), Prob) :-
-    gensym(reserved_newgoal, X),
-    term_variables((G1, G2), VarList),
-    NewHead =.. [X|VarList],
-    assertz((1::NewHead :- (G1, G2))),
-    inference_SC(NewHead, Prob),
-    writeln(1::NewHead),
-    ( VarList = [] ->
-        retract(1::NewHead) ;
-        % https://stackoverflow.com/a/55948034
-        retract((1::NewHead :- (G1, G2)))
-    ).
-
-
-% assumptions:
-%   G is the goal with only free variables
-%   G is non-compound; TODO: assert user input as clause and retract later
-%   ArgList contains the instantiated parameters for G
-
-% TODO: maybe this is better than our approach for replacing ground atoms with variables
-% https://stackoverflow.com/questions/37260614/prolog-replacing-subterms/53145013#53145013
-% replacee | replacement | term | res
-replace(Subterm0, Subterm, Term0, Term) :-
-    (Term0 == Subterm0
-        -> Term = Subterm
-        ; var(Term0)
-            -> Term = Term0
-            ; Term0 =.. [F|Args0],
-            maplist(replace(Subterm0,Subterm), Args0, Args),
-            Term =.. [F|Args]
-    ).
-
-replace_grounds(Term, [], [], Term) :- !. % no backtracking for base cases
-replace_grounds(Term, [GroundHead|GroundTail], [VarHead|VarTail], FreeTerm) :-
-    replace(GroundHead, VarHead, Term, ReplacedTerm),
-    replace_grounds(ReplacedTerm, GroundTail, VarTail, FreeTerm).
-
-% idea behind collect_grounds:
-% Same bindings will be replaced with same variables --> first collecting all bindings in list and only then replacing them 
-% destructure input term iteratively, ultimately reaching every ground atom that needs to be replaced by a free variable
-% based on current term structure three processing methods:
-%   variables: no replacement required --> ignored
-%   ground atoms: replacement required --> appending atom to GroundList so that it gets replaced later
-%   predicates: no replacement required --> destructuring with =.. and calling recursion on its arguments
-%
-% for compound goals: both depth and breadth recursion needed
-%   depth recursion: decomposing a single goal
-%   breadth recursion: recursively processing all subgoals, starting at the left-most
-
-% comment on cuts: prevent calling clauses further down when backtracking and therefore fail
-% breadth and depth base case: all subgoals of input goal have been processed
-collect_grounds([], [], []) :- !.
-% breadth recursion starting at depth base case:
-collect_grounds([], [RemainingHead|RemainingTail], GroundList) :-
-    collect_grounds([RemainingHead], RemainingTail, GroundList),
-    !.
-% depth recursion: handling variables
-collect_grounds([SubGoalHead|SubGoalTail], RemainingGoals, GroundList) :-
-    % SubGoalHead is a variable --> ignored
-    var(SubGoalHead),
-    !,
-    collect_grounds(SubGoalTail, RemainingGoals, GroundList).
-% depth recursion: handling ground atoms
-collect_grounds([SubGoalHead|SubGoalTail], RemainingGoals, [Functor|GroundTail]) :-
-    % SubGoalHead no variable as they were dealt with in previous clause (+!)
-    SubGoalHead =.. [Functor|Args],
-    % SubGoalHead is atomic and ground
-    Args = [],
-    !,
-    collect_grounds(SubGoalTail, RemainingGoals, GroundTail).
-% depth recursion: handling non-ground predicates
-collect_grounds([SubGoalHead|_], RemainingGoals, GroundList) :-
-    % SubGoalHead no variable as they were dealt with in previous clause (+!)
-    SubGoalHead =.. [_|Args],
-    Args \= [],
-    collect_grounds(Args, RemainingGoals, GroundList).
-
-
-free_bindings([FirstSubGoal], RemainingGoals, FreeGoals) :-
-    collect_grounds([FirstSubGoal], RemainingGoals, GroundList),
-    % list_to_set to obtain same variable name for same binding
-    list_to_set(GroundList, GroundSet),
-    % for each ground atom in GroundSet get one fresh free variable
-    length(GroundSet, GroundLength),
-    length(VarSet, GroundLength),
-    % for every ground atom in input goal: replace it with free variable, respecting same values
-    replace_grounds([FirstSubGoal|RemainingGoals], GroundSet, VarSet, FreeGoals).
-
 
 p(G, RoundedResult) :-
-    goal_to_list(G, [GHead|GTail]),
-    free_bindings([GHead], GTail, GFreeList),
+    goal_to_list(G, GList),
+    free_up_bindings(GList, GFreeList),
     goal_to_list(GFree, GFreeList),
     z(G, Numerator),
     z(GFree, Denominator),
     Result is Numerator / Denominator,
     round_third(Result, RoundedResult).
 
-% propagates bindings of CurrentGoal to RemainingGoal
-% the List in the form [X=a, Y=b, ...]
-% https://stackoverflow.com/a/64722773
-unify_helper(_, []) :- !.
-unify_helper(Term, [Var=Binding|BagTail]) :-
-    findall(Term, Var=Binding, [Term]),
-    unify_helper(Term, BagTail).
-
-% rounding result to third decimal
+% rounds to third decimal
 round_third(Float, RoundedFloat) :-
     RoundedScaled is round(Float*1000),
-    RoundedFloat is RoundedScaled/1000. 
+    RoundedFloat is RoundedScaled/1000.
 
+% unifSet_rec and substitSet_rec recursion require all subgoals
+% to be as unbound as possible. TODO: which subgoals?
+% free variable identifications must be preserved, e.g. p(X), q(X) --> p(Y), q(Y)
 
-unifSet_rec(_, _, [], 0) :- !. % base case cut: prevents further backtracking
-unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk) :-
-    % unifSet_rec recursion requires all subgoals to be as unbound as possible
-    % free variable relations must be preserved, e.g. p(X), q(X) must become p(Y), q(Y)
-    % -> copy everything but the current C (UnifClause)
+unifSet_rec(_, _, [], 0).
+unifSet_rec(CurrentGoal, RemainingGoal, [[CProb, CHead, CBody]|UnifSetTail], Akk) :-
+    % copy everything but the current C
     copy_term((CurrentGoal,RemainingGoal, UnifSetTail), (CurrentGoalFree,RemainingGoalFree, UnifSetTailFree)),
-
-    nth0(0, UnifClause, ClauseProb),
-    nth0(1, UnifClause, ClauseHead),
-    nth0(2, UnifClause, ClauseBody),
-    % UnifBag then has the instantiation of variables for the current C (UnifClause)
-    % e.g. [X=Y, Y=b]
-    unifiable(CurrentGoal, ClauseHead, UnifBag),
-    unify_helper(RemainingGoal, UnifBag), % TODO: how should unify_helper behave if variables in UnifBag have more unification options?
-    z((ClauseBody, RemainingGoal), Weight),
+    % instantiation of variables for the current C, e.g. [X=Y, Y=b]
+    unifiable(CurrentGoal, CHead, UnifBag),
+    % TODO: how should we unify if variables in UnifBag have more unification options?
+    unify_list(RemainingGoal, UnifBag),
+    z((CBody, RemainingGoal), Weight),
     unifSet_rec(CurrentGoalFree, RemainingGoalFree, UnifSetTailFree, Akknew),
-    Akk is ClauseProb*Weight + Akknew.
+    Akk is CProb*Weight + Akknew.
 
-substitSet_rec(_, _, [], 0) :- !. % base case cut: prevents further backtracking
+% third argument are suitable substitutions, as opposed to clauses in unifSet_rec
+substitSet_rec(_, _, [], 0).
 substitSet_rec(CurrentGoal, RemainingGoal, [Substitutions|PairedVarBindingsTail], Akk) :-
-    % substitSet_rec recursion requires all subgoals to be as unbound as possible
-    % PairedVarBindings must also remain unbound, e.g. old: [X=a], [X=b] becomes [Y=b] instead of [a=b]
-    % free variable relations must be preserved, e.g. p(X), q(X) must become p(Y), q(Y)
+    % PairedVarBindings must also remain unbound
+    % e.g. old: [X=a], [X=b] becomes [Y=b] instead of [a=b]
     copy_term((CurrentGoal,RemainingGoal, PairedVarBindingsTail), (CurrentGoalFree,RemainingGoalFree, PairedVarBindingsTailFree)),
-
-    % here, the third argument of substitSet_rec are suitable substitutions, as opposed to clauses in unifSet_rec
-    unify_helper(CurrentGoal, Substitutions),
-    unify_helper(RemainingGoal, Substitutions),
+    unify_list(CurrentGoal, Substitutions),
+    unify_list(RemainingGoal, Substitutions),
     z(CurrentGoal, Weight1),
     z(RemainingGoal, Weight2),
     % sum over all possible splitting substitutions
     substitSet_rec(CurrentGoalFree, RemainingGoalFree, PairedVarBindingsTailFree, Akknew),
     Akk is Weight1*Weight2 + Akknew.
 
-% base case
-z(true, 1) :- !. % preventing backtracking to clauses further down
-
-% compound base cases; simplifying conjunction
-% preventing backtracking to clauses further down
-z((G, true), Weight) :- z(G, Weight), !. % fires for G as body of a non-compound head
+% base cases, prevent backtracking to other clauses
+z(true, 1) :- !.
+% fires when e.g. G is body of non-compound head
+z((G, true), Weight) :- z(G, Weight), !.
 z((true, G), Weight) :- z(G, Weight), !.
 
-% compound head
 z((G1, G2), Weight) :-
-    G1 \= true, % mutual exclusivity of goals
-    %optimised z computation (with var Depth)
-    % shared variable test
+    % mutual exclusivity of goals
+    G1 \= true,
     sub_term_shared_variables(G1, (G1, G2), SharedVars),
-    ( SharedVars = [] 
+    (   SharedVars = []
     % no shared variables --> decomposition
     ->  z(G1, Weight1),
         z(G2, Weight2),
         Weight is Weight1*Weight2
-    % shared variables --> computation of splitting substitution set
+    % shared variables --> computation of Theta, the set of splitting substitutions
     ;   % only ground terms make goals disjunct (e.g. we don't want Y=Y)
         % collect all possible values of SharedVars in matching clause heads
-        % example: (G1, G2) === (s(X,Y), r(Y,Z))
-        % ---> SharedVars = [Y]
-        % ---> SubstitList = [[b],[c]]; in each entry list we have the bindings for all shared variables
+        % example: (G1, G2) = (s(X,Y), r(Y,Z))
+        % --> SharedVars = [Y]
+        % --> SubstitList = [[b],[c]]
+        %   (in each entry list we have the bindings for all shared variables)
         findall(SharedVars, (clause((_ :: G1), _), ground(SharedVars)), SubstitList),
-        % SubstitSet is Theta, the set of splitting substitutions. in the (s(X,Y), r(Y,Z)) case, a substitution of Y= b or Y= c makes the Variables in G1, G2 disjoint
+        % SubstitSet is now Theta
+        % in the case of (s(X,Y), r(Y,Z)), a substitution of Y=b or Y=c makes Vars in G1, G2 disjoint
         list_to_set(SubstitList, SubstitSet),
-        % put all possibilities for binding the shared variables into PairedVarBindings
+        % PairedVarBindings === all possibilities for binding the shared variables
         maplist(unifiable(SharedVars), SubstitSet, PairedVarBindings),
-        substitSet_rec(G1, G2, PairedVarBindings, Weight)        
-    ),
-    !. % preventing backtracking to clauses further down
+        substitSet_rec(G1, G2, PairedVarBindings, Weight)
+    ).
 
-% non-compound head
+% TODO: give example when this fires
 z(G, Weight) :-
     % mutual exclusivity of goals
     G \= (_, _),
     G \= true,
-
     findall([Prob, G, Body], clause((Prob :: G), Body), UnifSet),
     unifSet_rec(G, true, UnifSet, Weight).
 
-
-% loglinear: ähnlich zum v1, nur ohne inference call
-% unification-constrained: in der effizienz zwischen loglinear und backtrackable
-% backtrackable: hier implementieren
-% importance: wahrscheinlich ein improvement zum improved loglinear
-
-% TODO: what is the expected result for sampling a goal that doesn't exist?
-% unconstrained (loglinear) sampling
+% unconstrained loglinear sampling
 sample_UC(Head) :-
     findall([Prob::Head, Body], clause((Prob :: Head), Body), ClauseBag),
-    % probabilisticly choosing a clause in ClauseBag --> binding Head and Body
+    % probabilistic clause selector binds Head and Body
     random_clause(Head, Body, ClauseBag),
-    % we just sample once for now, i.e. sticking to the choice of random_clause
+    % sample once - stick to choice of random_clause
     !,
     sample_UC(Body).
 
-% compound body
 sample_UC((G1, G2)) :-
     !,
     sample_UC(G1),
     sample_UC(G2).
 
-% base case: true or fail. returns "false" when encountering fail
+% base case: true or fail.
+% executes "fail" when encountering failure, making sure
+% we don't get spurious bindings through backtracking.
 sample_UC(G) :-
-    % writeln(G),
     !,
-    G. % executes "fail" when encountering failure, making sure we don't get spurious bindings through backtracking.
+    G.
 
 random_clause(Head, Body, ClauseBag) :-
     transform_probabilities(ClauseBag, ShiftedClauseBag),
-    % generating random float between 0 and 1
+    % get random float between 0 and 1
     Rand is random_float,
     choose(ShiftedClauseBag, Rand, [Head, Body]).
 
 choose([], _, false).
 choose([[ShiftedProb::ShiftedHead, Body]|Tail], SampleProb, Sample) :-
-    ( ShiftedProb >= SampleProb
-    -> Sample = [ShiftedHead, Body]
-    ; choose(Tail, SampleProb, Sample)).
+    (   ShiftedProb >= SampleProb
+    ->  Sample = [ShiftedHead, Body]
+    ;   choose(Tail, SampleProb, Sample)
+    ).
 
-% shift the probabilities so we can sample from a uniform distribution
+% shift probabilities so we can sample from uniform distribution
 % implicit failure/base case:
 % probability of failure === 1 - sum of probabilities for successful cases
 transform_probabilities([[P::H, B]], [[P::H, B], Failure]) :-
-    % need a head with the same functor and arity, but all free variables as arguments
+    % need head with same functor and arity, but all free variables as args
     functor(H, FailureName, FailureArity),
     length(K, FailureArity),
     FailureH =.. [FailureName|K],
@@ -289,28 +228,24 @@ transform_probabilities([[P1::H1, B1],[P2::H2, B2]|Tail], L) :-
     transform_probabilities([[TransfromedProb::H2, B2]|Tail], TempL),
     L = [[P1::H1, B1]|TempL].
 
-%-----
-
+% success-constrained backtrackable sampling
 sample_SC(Head) :-
     findall([Prob::Head, Body], clause((Prob :: Head), Body), ClauseBag),
-    % probabilisticly choosing a clause in ClauseBag --> binding Head and Body
     random_clause(Head, Body, ClauseBag),
     % Head + Body ground; bind Prob
     clause((Prob :: Head), Body),
     !,
-    ( sample_SC(Body)
-    -> !
+    (   sample_SC(Body)
+    ->  !
     % if we fail in the above, preprocess the tree, rewriting probabilities
     ;   writeln([Prob::Head, Body]),
-        % sum of clause probabilities with current Head without the failed clause Prob::Head :- Body
-        % recursively all failing clauses get removed --> sum decreasing continuously
+        % probabilities of current Head without the failed clause Prob::Head :- Body
         sum_remaining(ClauseBag, Prob, 0, Denominator),
         writeln(Denominator),
-        % rewrite probabilities of remaining clauses proportional to the successful branches
+        % rewrite probabilities of remaining clauses proportional to remaining branches
         change_prob(ClauseBag, [Prob::Head, Body], Denominator)
     ).
 
-% compound body
 sample_SC((G1, G2)) :-
     sample_SC(G1),
     sample_SC(G2).
@@ -319,14 +254,14 @@ sample_SC(G) :-
     G.
 
 change_prob([], [_::_, _], _).
-% failed clause Prob::Head :- Body -> 0 probability
+% failed clause Prob::Head :- Body --> 0 probability
 change_prob([[Prob::Head, Body]|BagTail], [Prob::Head, Body], Denominator) :-
     writeln([Prob::Head, Body]),
-    retract(Prob::Head :- Body), % TODO: will it work for ground clauses, too?
-    assertz(0::Head :- Body),
+    retract(Prob::Head :- Body),
+    % assertz(0::Head :- Body),
     change_prob(BagTail, [Prob::Head, Body], Denominator).
-% otherwise -> adjust
-% TODO: why no backtracking of failed case to this clause?
+% otherwise --> adjust
+% no backtracking of failed case to this because clause with that Prob was retracted
 change_prob([[P::H, B]|BagTail], [Prob::Head, Body], Denominator) :-
     writeln(BagTail),
     retract(P::H :- B),
@@ -340,11 +275,9 @@ sum_remaining([[P::_, _]|BagTail], FailedP, Akk, Denominator) :-
     Akknew is Akk + P,
     sum_remaining(BagTail, FailedP, Akknew, Denominator).
 
-% p(X) :- q1(X), q2(X).
-% q1(a).
-% q2(X) :- fail.
 
 % TESTS
+:- style_check(-singleton).
 
 % sample_SC tree rewriting test:
 % have:
@@ -399,7 +332,6 @@ sum_remaining([[P::_, _]|BagTail], FailedP, Akk, Denominator) :-
 0.6 :: f(X).
 0.2 :: f(X) :- fail.
 
-% XXX: p(cmp1(b), P). -> zero divisor
 0.5 :: cmp1(X, Y) :- dq(X), dq(Y).
 
 0.5 :: cmp(X) :- p(X), q(X).

commit eed601675967e4a01e65554eb909eabab7ecede2
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Fri Sep 22 15:41:50 2023 +0200

    inference_marginal implementation with backtracking; inference_SC_test === new backtracking superstructure for p call, symmetric to inference_marginal, less hacky; updating TODOs; deleting inference_marginal test file

diff --git a/src/demo_doc.pl b/src/demo_doc.pl
index 769058b..40f82c7 100644
--- a/src/demo_doc.pl
+++ b/src/demo_doc.pl
@@ -1,5 +1,4 @@
 % TODO
-% R inference_marginal(qq(X),P). ---> P = [[X=X, 0.6], [X=a, 0.2]] ; (should be 0.8)
 % M constrained sampling
 % ? bringing pack p/3 implementation for free query input (e.g. probs differ for t(X, X) and t(X,Y) on calling t(a,a) if clause t(a, g) exists)
 % ? motivate p/3 with a test case
@@ -7,27 +6,25 @@
 % R demo / tests
 % M cuts
 % M code organisation / refactor
-% R improving output of marginal and remove type error (Weight can be float in SC case or List of Lists in marginal case)
 % ? can sampling(G) call (for G either true or fail) be integrated in other cases? (both sampling_UC and sampling_SC)
 % M compound assert/retract inference_SC
-% R theta splitting for marginal
 % M err if a functor's labels sum to >1'
 % M special sampling mit SC inference
 
-% - nested functors: st(qq(X)) : inference, sampling
+% - nested functors: st(dqq(X)) : inference, sampling
 % - impure
 % - disjunction
 
-0.6 :: q(X).
-0.2 :: q(a).
+0.6 :: dq(X).
+0.2 :: dq(a).
 % we have implicit failure, so, additionally:
-% 0.2 :: q(X) :- fail.
+% 0.2 :: dq(X) :- fail.
 % each functor's probability labels must sum to 1
 % <1: implicit failure
 % >1: error out
 
-5/10 :: qq(a).
-3/10 :: qq(b).
+5/10 :: dqq(a).
+3/10 :: dqq(b).
 
 0.5 :: st2(X) :- stt2(X).
 0.5 :: st2(X) :- sst3(X).
@@ -41,33 +38,33 @@
 % --------------------
 
 % inference: marginal
-% forall X. what is P such that q(X) terminates successfully
+% forall X. what is P such that dq(X) terminates successfully
 % implementation: summation over bindings yields the denominator z in Cussen's p (for ground queries; for non-ground it [check this] corresponds to the denominator)
-% API: inference_marginal(q(X), P).
+% API: inference_marginal(dq(X), P).
 % ---> X = <binding>, P = <number>
-% inference_marginal(q(X), P).
+% inference_marginal(dq(X), P).
 % ---> X = Omega - {a}, P = 0.6.
 % ---> X = a, P = 0.8
-% inference_marginal(q(b), P).
+% inference_marginal(dq(b), P).
 % ---> X = b, P = 0.6
-% inference_marginal(qq(X), P).
+% inference_marginal(dqq(X), P).
 % ---> X = a, P = 5/10.
 % ---> X = b, P = 3/10.
-% [inference_marginal(q(a), P).
+% [inference_marginal(dq(a), P).
 % ---> P = 0.8.] <- the case where the query is ground is always determined by the corresponding result in the non-ground case
 
 % --------------------
 
 % inference: success-constrained
-% Given q(X) terminates successfully, what is the probability distribution of X as a random variable
+% Given dq(X) terminates successfully, what is the probability distribution of X as a random variable
 % this is just the P's for each variable binding.
 % implementation: Cussen's p
-%   the denominator z(q(X), P) gives P = 0.8 because [check this] that is the required normalization weight for the correct final result
-% inference_sc(q(X), P).
+%   the denominator z(dq(X), P) gives P = 0.8 because [check this] that is the required normalization weight for the correct final result
+% inference_sc(dq(X), P).
 % ---> X = a, P = 1
-% inference_sc(q(b), P).
+% inference_sc(dq(b), P).
 % ---> X = b, P = 0.75
-% inference_sc(qq(X), P).
+% inference_sc(dqq(X), P).
 % ---> X = a, P = 5/8
 % ---> X = b, P = 3/8
 
diff --git a/src/inference_marginal.pl b/src/inference_marginal.pl
deleted file mode 100644
index 017e61d..0000000
--- a/src/inference_marginal.pl
+++ /dev/null
@@ -1,76 +0,0 @@
-% when the VarList is exhausted, set the result to the singe remaining entry in the weight, that entry is the probability
-replace_left([], Remains, Remains).
-replace_left([NewL|TailNewL], [_=R|Tail], [NewL=R|Res]) :-
-    var(NewL),
-    replace_left(TailNewL, Tail, Res).
-% ignoring already globally bound variables s.t. lenght of binding list [_=R|Tail] equals list of new lefts [NewL|TailNewL]
-replace_left([NewL|TailNewL], [_=R|Tail], Res) :-
-    nonvar(NewL),
-    replace_left(TailNewL, [_=R|Tail], Res).
-
-
-% example call: inference_marginal((s(X,Y),r(Y,Z)), Prob)
-% in the general case, one Variable (TODO: which?) is not part of the list in Weight but rather detemined by backtracking
-inference_marginal(Goal, ProbList) :-
-% example goal: (s(X,Y), r(Y,Z))
-% ---> VarList === [X,Y,Z]
-% after z call: VarList === [X,b,Z]
-% because of that:
-% preserving variable names for pretty output
-% TODO: may order of vars in list differ from the order in the output list?
-term_variables(Goal, VarList),
-z(Goal, Weight), 
-% for the example goal of (s(X,Y), r(Y,Z)), we currently have
-% Y=b,
-% Weight = [[b=b, _=X, 0.14], [c=c, _=a, 0], [b=b, _=b, 0.04]]
-% invariant: forall w in Weight. len(VarList - ground terms) === len(w - last element)
-% replace_left then takes the variables from VarList and replaces the left hand '=' sides with them in order (for each w in Weight [is a list])
-maplist(replace_left(VarList), Weight, ProbList).
-
-
-% base case
-z(true, 1) :- !. % preventing backtracking to clauses further down
-
-% compound base cases; simplifying conjunction
-% preventing backtracking to clauses further down
-z((G, true), Weight) :- z(G, Weight), !. % fires for G as body of a non-compound head
-z((true, G), Weight) :- z(G, Weight), !.
-
-% compound head
-z((G1, G2), Weight) :-
-    G1 \= true, % mutual exclusivity of goals
-    %optimised z computation (with var Depth)
-    % shared variable test
-    sub_term_shared_variables(G1, (G1, G2), SharedVars),
-    ( SharedVars = [] 
-    % no shared variables --> decomposition
-    ->  z(G1, Weight1),
-        z(G2, Weight2),
-        Weight is Weight1*Weight2
-    % shared variables --> computation of splitting substitution set
-    ;   % only ground terms make goals disjunct (e.g. we don't want Y=Y)
-        % collect all possible values of SharedVars in matching clause heads
-        % example: (G1, G2) === (s(X,Y), r(Y,Z))
-        % ---> SharedVars = [Y]
-        % ---> SubstitList = [[b],[c]]; in each entry list we have the bindings for all shared variables
-        findall(SharedVars, (clause((_ :: G1), _), ground(SharedVars)), SubstitList),
-        % SubstitSet is Theta, the set of splitting substitutions. in the (s(X,Y), r(Y,Z)) case, a substitution of Y= b or Y= c makes the Variables in G1, G2 disjoint
-        list_to_set(SubstitList, SubstitSet),
-        % put all possibilities for binding the shared variables into PairedVarBindings
-        maplist(unifiable(SharedVars), SubstitSet, PairedVarBindings),
-        substitSet_rec(G1, G2, PairedVarBindings, Weight)        
-    ),
-    !. % preventing backtracking to clauses further down
-
-% non-compound head
-z(G, Weight) :-
-    % mutual exclusivity of goals
-    G \= (_, _),
-    G \= true,
-
-    findall([Prob, G, Body], clause((Prob :: G), Body), UnifSet),
-    unifSet_rec(G, true, UnifSet, Weight).
-
-
-%findall([Prob, G1, Body], clause((Prob :: G1), Body), UnifSet),
-%        unifSet_rec(G1, G2, UnifSet, Weight, Depth)
\ No newline at end of file
diff --git a/src/slp.pl b/src/slp.pl
index 685186f..d13ec09 100644
--- a/src/slp.pl
+++ b/src/slp.pl
@@ -11,31 +11,47 @@
 % transferring initial goal to list
 goal_to_list((G1, G2), [G1|GoalTail]) :- goal_to_list(G2, GoalTail).
 goal_to_list(G, [G]) :- G \= (_ , _).
+
+% forcing backtracking over possible bindings for free variables in Goal
+bind_goal([]).
+bind_goal([GoalHead|GoalTail]) :-
+    clause((_::GoalHead), _),
+    bind_goal(GoalTail).
+
+inference_marginal(Goal, ProbRounded) :-
+    goal_to_list(Goal, GoalList),
+    bind_goal(GoalList),
+    goal_to_list(GoalBound, GoalList),
+    term_variables(GoalBound, VarList),
+    ( VarList \= [] -> writeln('true,'); true),
+    z(GoalBound, Prob),
+    round_third(Prob, ProbRounded).
+
+inference_SC_test(Goal, ProbRounded) :-
+    goal_to_list(Goal, GoalList),
+    bind_goal(GoalList),
+    goal_to_list(GoalBound, GoalList),
+    term_variables(GoalBound, VarList),
+    ( VarList \= [] -> writeln('true,'); true),
+    p(GoalBound, Prob),
+    round_third(Prob, ProbRounded).
     
 inference_SC(G, Prob) :-
     G \= (_, _),
     clause(_::G, _),
     % checking if variables are still free (e.g. X=X), then VarList won't be empty
-    writeln('xxx'),
     term_variables(G, VarList),
-    writeln('<<'),
     ( VarList \= [] -> writeln('true,'); true),
-    writeln('sdfsd'),
-    p(G, Prob),
-    writeln('aaaaaaaaaaaa').
+    p(G, Prob).
 
 % doesnt work for ground goals:
 % inference_SC((q(a), p(a)), P).
 inference_SC((G1,G2), Prob) :-
     gensym(reserved_newgoal, X),
     term_variables((G1, G2), VarList),
-    writeln('aaa'),
     NewHead =.. [X|VarList],
-    writeln('bbb'),
     assertz((1::NewHead :- (G1, G2))),
-    writeln('ccc'),
     inference_SC(NewHead, Prob),
-    writeln('ddd'),
     writeln(1::NewHead),
     ( VarList = [] ->
         retract(1::NewHead) ;
@@ -371,9 +387,11 @@ sum_remaining([[P::_, _]|BagTail], FailedP, Akk, Denominator) :-
 0.6 :: q(b).
 0.1 :: q(c).
 
-0.6 :: qq(X).
-0.2 :: qq(a).
-0.1 :: qq(b).
+0.6 :: dq(X).
+0.2 :: dq(a).
+
+5/10 :: dqq(a).
+3/10 :: dqq(b).
 
 0.5 :: compound(X) :- p(X), q(X).
 
@@ -382,7 +400,7 @@ sum_remaining([[P::_, _]|BagTail], FailedP, Akk, Denominator) :-
 0.2 :: f(X) :- fail.
 
 % XXX: p(cmp1(b), P). -> zero divisor
-0.5 :: cmp1(X, Y) :- qq(X), qq(Y).
+0.5 :: cmp1(X, Y) :- dq(X), dq(Y).
 
 0.5 :: cmp(X) :- p(X), q(X).
 

commit b739b899b34358a62e501e7fce74a6b7237d101a
Merge: cfec21d 01f29f1
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Fri Sep 22 14:47:56 2023 +0200

    new TODO entry

commit cfec21da1e79e54d9b5fb70b8132b16a94a5ab18
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Fri Sep 22 14:11:52 2023 +0200

    TODO update

diff --git a/src/demo_doc.pl b/src/demo_doc.pl
index 8f3bb30..769058b 100644
--- a/src/demo_doc.pl
+++ b/src/demo_doc.pl
@@ -1,13 +1,15 @@
 % TODO
-% R free_bindings umschreiben für replace
 % R inference_marginal(qq(X),P). ---> P = [[X=X, 0.6], [X=a, 0.2]] ; (should be 0.8)
 % M constrained sampling
+% ? bringing pack p/3 implementation for free query input (e.g. probs differ for t(X, X) and t(X,Y) on calling t(a,a) if clause t(a, g) exists)
+% ? motivate p/3 with a test case
+% ? backtracking for inference: test functionality scope of current implementation
 % R demo / tests
 % M cuts
 % M code organisation / refactor
 % R improving output of marginal and remove type error (Weight can be float in SC case or List of Lists in marginal case)
+% ? can sampling(G) call (for G either true or fail) be integrated in other cases? (both sampling_UC and sampling_SC)
 % M compound assert/retract inference_SC
-% R p zero divisor
 % R theta splitting for marginal
 % M err if a functor's labels sum to >1'
 % M special sampling mit SC inference
diff --git a/src/inference_marginal.pl b/src/inference_marginal.pl
new file mode 100644
index 0000000..a8a8de3
--- /dev/null
+++ b/src/inference_marginal.pl
@@ -0,0 +1,33 @@
+% when the VarList is exhausted, set the result to the singe remaining entry in the weight, that entry is the probability
+replace_left([], Remains, Remains).
+replace_left([NewL|TailNewL], [_=R|Tail], [NewL=R|Res]) :-
+    var(NewL),
+    replace_left(TailNewL, Tail, Res).
+% ignoring already globally bound variables s.t. lenght of binding list [_=R|Tail] equals list of new lefts [NewL|TailNewL]
+replace_left([NewL|TailNewL], [_=R|Tail], Res) :-
+    nonvar(NewL),
+    replace_left(TailNewL, [_=R|Tail], Res).
+
+
+% example call: inference_marginal((s(X,Y),r(Y,Z)), Prob)
+% in the general case, one Variable (TODO: which?) is not part of the list in Weight but rather detemined by backtracking
+inference_marginal(Goal, ProbList) :-
+% example goal: (s(X,Y), r(Y,Z))
+% ---> VarList === [X,Y,Z]
+% after z call: VarList === [X,b,Z]
+% because of that:
+% preserving variable names for pretty output
+% TODO: may order of vars in list differ from the order in the output list?
+term_variables(Goal, VarList),
+z(Goal, Weight), 
+% for the example goal of (s(X,Y), r(Y,Z)), we currently have
+% Y=b,
+% Weight = [[b=b, _=X, 0.14], [c=c, _=a, 0], [b=b, _=b, 0.04]]
+% invariant: forall w in Weight. len(VarList - ground terms) === len(w - last element)
+% replace_left then takes the variables from VarList and replaces the left hand '=' sides with them in order (for each w in Weight [is a list])
+maplist(replace_left(VarList), Weight, ProbList).
+
+
+
+findall([Prob, G1, Body], clause((Prob :: G1), Body), UnifSet),
+        unifSet_rec(G1, G2, UnifSet, Weight, Depth)
\ No newline at end of file
diff --git a/src/slp.pl b/src/slp.pl
index 9fba021..685186f 100644
--- a/src/slp.pl
+++ b/src/slp.pl
@@ -7,15 +7,6 @@
 %   normalized SLP (all clauses forming a predicate add up to 1)
 %   pure SLP (no non-prob. clauses)
 
-% when the VarList is exhausted, set the result to the singe remaining entry in the weight, that entry is the probability
-replace_left([], Remains, Remains).
-replace_left([NewL|TailNewL], [_=R|Tail], [NewL=R|Res]) :-
-    var(NewL),
-    replace_left(TailNewL, Tail, Res).
-% ignoring already globally bound variables s.t. lenght of binding list [_=R|Tail] equals list of new lefts [NewL|TailNewL]
-replace_left([NewL|TailNewL], [_=R|Tail], Res) :-
-    nonvar(NewL),
-    replace_left(TailNewL, [_=R|Tail], Res).
 
 % transferring initial goal to list
 goal_to_list((G1, G2), [G1|GoalTail]) :- goal_to_list(G2, GoalTail).
@@ -52,24 +43,6 @@ inference_SC((G1,G2), Prob) :-
         retract((1::NewHead :- (G1, G2)))
     ).
 
-% example call: inference_marginal((s(X,Y),r(Y,Z)), Prob)
-% in the general case, one Variable (TODO: which?) is not part of the list in Weight but rather detemined by backtracking
-inference_marginal(Goal, ProbList) :-
-    % example goal: (s(X,Y), r(Y,Z))
-    % ---> VarList === [X,Y,Z]
-    % after z call: VarList === [X,b,Z]
-    % because of that:
-    % preserving variable names for pretty output
-    % TODO: may order of vars in list differ from the order in the output list?
-    term_variables(Goal, VarList),
-    z(Goal, Weight, 0), 
-    % for the example goal of (s(X,Y), r(Y,Z)), we currently have
-    % Y=b,
-    % Weight = [[b=b, _=X, 0.14], [c=c, _=a, 0], [b=b, _=b, 0.04]]
-    % invariant: forall w in Weight. len(VarList - ground terms) === len(w - last element)
-    % replace_left then takes the variables from VarList and replaces the left hand '=' sides with them in order (for each w in Weight [is a list])
-    maplist(replace_left(VarList), Weight, ProbList).
-
 
 % assumptions:
 %   G is the goal with only free variables
@@ -94,6 +67,18 @@ replace_grounds(Term, [GroundHead|GroundTail], [VarHead|VarTail], FreeTerm) :-
     replace(GroundHead, VarHead, Term, ReplacedTerm),
     replace_grounds(ReplacedTerm, GroundTail, VarTail, FreeTerm).
 
+% idea behind collect_grounds:
+% Same bindings will be replaced with same variables --> first collecting all bindings in list and only then replacing them 
+% destructure input term iteratively, ultimately reaching every ground atom that needs to be replaced by a free variable
+% based on current term structure three processing methods:
+%   variables: no replacement required --> ignored
+%   ground atoms: replacement required --> appending atom to GroundList so that it gets replaced later
+%   predicates: no replacement required --> destructuring with =.. and calling recursion on its arguments
+%
+% for compound goals: both depth and breadth recursion needed
+%   depth recursion: decomposing a single goal
+%   breadth recursion: recursively processing all subgoals, starting at the left-most
+
 % comment on cuts: prevent calling clauses further down when backtracking and therefore fail
 % breadth and depth base case: all subgoals of input goal have been processed
 collect_grounds([], [], []) :- !.
@@ -123,13 +108,14 @@ collect_grounds([SubGoalHead|_], RemainingGoals, GroundList) :-
     collect_grounds(Args, RemainingGoals, GroundList).
 
 
-free_bindings(FirstSubGoal, RemainingGoals, FreeGoals) :-
-    collect_grounds(FirstSubGoal, RemainingGoals, GroundList),
+free_bindings([FirstSubGoal], RemainingGoals, FreeGoals) :-
+    collect_grounds([FirstSubGoal], RemainingGoals, GroundList),
     % list_to_set to obtain same variable name for same binding
     list_to_set(GroundList, GroundSet),
     % for each ground atom in GroundSet get one fresh free variable
     length(GroundSet, GroundLength),
     length(VarSet, GroundLength),
+    % for every ground atom in input goal: replace it with free variable, respecting same values
     replace_grounds([FirstSubGoal|RemainingGoals], GroundSet, VarSet, FreeGoals).
 
 
@@ -137,8 +123,8 @@ p(G, RoundedResult) :-
     goal_to_list(G, [GHead|GTail]),
     free_bindings([GHead], GTail, GFreeList),
     goal_to_list(GFree, GFreeList),
-    z(G, Numerator, _),
-    z(GFree, Denominator, _),
+    z(G, Numerator),
+    z(GFree, Denominator),
     Result is Numerator / Denominator,
     round_third(Result, RoundedResult).
 
@@ -155,10 +141,9 @@ round_third(Float, RoundedFloat) :-
     RoundedScaled is round(Float*1000),
     RoundedFloat is RoundedScaled/1000. 
 
-% Akk is the Weight, can be a float or a List. zero depth base case for concatenation: need empty lists. Depth gets increased in each z recursion, not per unifSet_rec recursion
-unifSet_rec(_, _, [], [], Depth) :- nonvar(Depth), Depth = 0, !.
-unifSet_rec(_, _, [], 0, _) :- !. % base case cut: prevents further backtracking and final output "false"
-unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk, Depth) :-
+
+unifSet_rec(_, _, [], 0) :- !. % base case cut: prevents further backtracking
+unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk) :-
     % unifSet_rec recursion requires all subgoals to be as unbound as possible
     % free variable relations must be preserved, e.g. p(X), q(X) must become p(Y), q(Y)
     % -> copy everything but the current C (UnifClause)
@@ -171,22 +156,12 @@ unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk, Depth) :-
     % e.g. [X=Y, Y=b]
     unifiable(CurrentGoal, ClauseHead, UnifBag),
     unify_helper(RemainingGoal, UnifBag), % TODO: how should unify_helper behave if variables in UnifBag have more unification options?
-    % incrementing Depth value for marginal inference when reaching new level for z recursion
-    ( nonvar(Depth) -> DepthNew is Depth+1; DepthNew = Depth),
-    z((ClauseBody, RemainingGoal), Weight, DepthNew),
-    unifSet_rec(CurrentGoalFree, RemainingGoalFree, UnifSetTailFree, Akknew, Depth),
-    ( nonvar(Depth), Depth = 0
-        % marginal inf toplevel
-        ->  BindingProb is ClauseProb*Weight,
-            round_third(BindingProb, BindingProbRound), % rounding probability occurring in output
-            % [X=Y, Y=b] <> [0.3] === [X=Y, Y=b, 0.3]
-            append(UnifBag, [BindingProbRound], AkkTemp),
-            append([AkkTemp], Akknew, Akk) % for all but the last element in unif set Akknew will be a list
-        % SC inf / marginal recursive
-        ;   Akk is ClauseProb*Weight + Akknew).
-
-substitSet_rec(_, _, [], 0, _) :- !. % base case cut: prevents further backtracking and final output "false"
-substitSet_rec(CurrentGoal, RemainingGoal, [Substitutions|PairedVarBindingsTail], Akk, Depth) :-
+    z((ClauseBody, RemainingGoal), Weight),
+    unifSet_rec(CurrentGoalFree, RemainingGoalFree, UnifSetTailFree, Akknew),
+    Akk is ClauseProb*Weight + Akknew.
+
+substitSet_rec(_, _, [], 0) :- !. % base case cut: prevents further backtracking
+substitSet_rec(CurrentGoal, RemainingGoal, [Substitutions|PairedVarBindingsTail], Akk) :-
     % substitSet_rec recursion requires all subgoals to be as unbound as possible
     % PairedVarBindings must also remain unbound, e.g. old: [X=a], [X=b] becomes [Y=b] instead of [a=b]
     % free variable relations must be preserved, e.g. p(X), q(X) must become p(Y), q(Y)
@@ -195,58 +170,55 @@ substitSet_rec(CurrentGoal, RemainingGoal, [Substitutions|PairedVarBindingsTail]
     % here, the third argument of substitSet_rec are suitable substitutions, as opposed to clauses in unifSet_rec
     unify_helper(CurrentGoal, Substitutions),
     unify_helper(RemainingGoal, Substitutions),
-    z(CurrentGoal, Weight1, Depth),
-    z(RemainingGoal, Weight2, Depth),
+    z(CurrentGoal, Weight1),
+    z(RemainingGoal, Weight2),
     % sum over all possible splitting substitutions
-    substitSet_rec(CurrentGoalFree, RemainingGoalFree, PairedVarBindingsTailFree, Akknew, Depth),
+    substitSet_rec(CurrentGoalFree, RemainingGoalFree, PairedVarBindingsTailFree, Akknew),
     Akk is Weight1*Weight2 + Akknew.
 
 % base case
-z(true, 1, _).
+z(true, 1) :- !. % preventing backtracking to clauses further down
 
 % compound base cases; simplifying conjunction
-% base case cuts: prevent further backtracking and final output "false"
-z((G, true), Weight, Depth) :- z(G, Weight, Depth), !. % fires for G as body of a non-compound head
-z((true, G), Weight, Depth) :- z(G, Weight, Depth), !.
+% preventing backtracking to clauses further down
+z((G, true), Weight) :- z(G, Weight), !. % fires for G as body of a non-compound head
+z((true, G), Weight) :- z(G, Weight), !.
 
 % compound head
-z((G1, G2), Weight, Depth) :-
+z((G1, G2), Weight) :-
     G1 \= true, % mutual exclusivity of goals
-    % marginal inference --> standard not optimised z computation (with nonvar Depth)
-    ( nonvar(Depth) 
-    ->  findall([Prob, G1, Body], clause((Prob :: G1), Body), UnifSet),
-        unifSet_rec(G1, G2, UnifSet, Weight, Depth)
-    % success constraint inference --> optimised z computation (with var Depth)
-    ;   % shared variable test
-        sub_term_shared_variables(G1, (G1, G2), SharedVars),
-        ( SharedVars = [] 
-        % no shared variables --> decomposition
-        ->  z(G1, Weight1, Depth),
-            z(G2, Weight2, Depth),
-            Weight is Weight1*Weight2
-        % shared variables --> computation of splitting substitution set
-        ;   % only ground terms make goals disjunct (e.g. we don't want Y=Y)
-            % collect all possible values of SharedVars in matching clause heads
-            % example: (G1, G2) === (s(X,Y), r(Y,Z))
-            % ---> SharedVars = [Y]
-            % ---> SubstitList = [[b],[c]]; in each entry list we have the bindings for all shared variables
-            findall(SharedVars, (clause((_ :: G1), _), ground(SharedVars)), SubstitList),
-            % SubstitSet is Theta, the set of splitting substitutions. in the (s(X,Y), r(Y,Z)) case, a substitution of Y= b or Y= c makes the Variables in G1, G2 disjoint
-            list_to_set(SubstitList, SubstitSet),
-            % put all possibilities for binding the shared variables into PairedVarBindings
-            maplist(unifiable(SharedVars), SubstitSet, PairedVarBindings),
-            substitSet_rec(G1, G2, PairedVarBindings, Weight, Depth)        
-        )
-    ).
+    %optimised z computation (with var Depth)
+    % shared variable test
+    sub_term_shared_variables(G1, (G1, G2), SharedVars),
+    ( SharedVars = [] 
+    % no shared variables --> decomposition
+    ->  z(G1, Weight1),
+        z(G2, Weight2),
+        Weight is Weight1*Weight2
+    % shared variables --> computation of splitting substitution set
+    ;   % only ground terms make goals disjunct (e.g. we don't want Y=Y)
+        % collect all possible values of SharedVars in matching clause heads
+        % example: (G1, G2) === (s(X,Y), r(Y,Z))
+        % ---> SharedVars = [Y]
+        % ---> SubstitList = [[b],[c]]; in each entry list we have the bindings for all shared variables
+        findall(SharedVars, (clause((_ :: G1), _), ground(SharedVars)), SubstitList),
+        % SubstitSet is Theta, the set of splitting substitutions. in the (s(X,Y), r(Y,Z)) case, a substitution of Y= b or Y= c makes the Variables in G1, G2 disjoint
+        list_to_set(SubstitList, SubstitSet),
+        % put all possibilities for binding the shared variables into PairedVarBindings
+        maplist(unifiable(SharedVars), SubstitSet, PairedVarBindings),
+        substitSet_rec(G1, G2, PairedVarBindings, Weight)        
+    ),
+    !. % preventing backtracking to clauses further down
 
 % non-compound head
-z(G, Weight, Depth) :-
+z(G, Weight) :-
     % mutual exclusivity of goals
     G \= (_, _),
     G \= true,
 
     findall([Prob, G, Body], clause((Prob :: G), Body), UnifSet),
-    unifSet_rec(G, true, UnifSet, Weight, Depth).
+    unifSet_rec(G, true, UnifSet, Weight).
+
 
 % loglinear: ähnlich zum v1, nur ohne inference call
 % unification-constrained: in der effizienz zwischen loglinear und backtrackable

commit 01f29f1fa7d7bd8d86cda4880fd266105dd46e03
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Fri Sep 22 14:11:52 2023 +0200

    commenting collect_grounds

diff --git a/src/demo_doc.pl b/src/demo_doc.pl
index 8f3bb30..d76fd39 100644
--- a/src/demo_doc.pl
+++ b/src/demo_doc.pl
@@ -1,7 +1,8 @@
 % TODO
-% R free_bindings umschreiben für replace
 % R inference_marginal(qq(X),P). ---> P = [[X=X, 0.6], [X=a, 0.2]] ; (should be 0.8)
 % M constrained sampling
+% ? bringing pack p/3 implementation for free query input (e.g. probs differ for t(X, X) and t(X,Y) on calling t(a,a) if clause t(a, g) exists)
+% ? motivate p/3 with a test case
 % R demo / tests
 % M cuts
 % M code organisation / refactor
diff --git a/src/slp.pl b/src/slp.pl
index 9fba021..bca4855 100644
--- a/src/slp.pl
+++ b/src/slp.pl
@@ -94,6 +94,18 @@ replace_grounds(Term, [GroundHead|GroundTail], [VarHead|VarTail], FreeTerm) :-
     replace(GroundHead, VarHead, Term, ReplacedTerm),
     replace_grounds(ReplacedTerm, GroundTail, VarTail, FreeTerm).
 
+% idea behind collect_grounds:
+% Same bindings will be replaced with same variables --> first collecting all bindings in list and only then replacing them 
+% destructure input term iteratively, ultimately reaching every ground atom that needs to be replaced by a free variable
+% based on current term structure three processing methods:
+%   variables: no replacement required --> ignored
+%   ground atoms: replacement required --> appending atom to GroundList so that it gets replaced later
+%   predicates: no replacement required --> destructuring with =.. and calling recursion on its arguments
+%
+% for compound goals: both depth and breadth recursion needed
+%   depth recursion: decomposing a single goal
+%   breadth recursion: recursively processing all subgoals, starting at the left-most
+
 % comment on cuts: prevent calling clauses further down when backtracking and therefore fail
 % breadth and depth base case: all subgoals of input goal have been processed
 collect_grounds([], [], []) :- !.
@@ -130,6 +142,7 @@ free_bindings(FirstSubGoal, RemainingGoals, FreeGoals) :-
     % for each ground atom in GroundSet get one fresh free variable
     length(GroundSet, GroundLength),
     length(VarSet, GroundLength),
+    % for every ground atom in input goal: replace it with free variable, respecting same values
     replace_grounds([FirstSubGoal|RemainingGoals], GroundSet, VarSet, FreeGoals).
 
 

commit 67640d5ee5123c9dd832d68f94d68c42b0663e7a
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Fri Sep 22 13:37:24 2023 +0200

    free_bindings rewritten, now based on collect_grounds and replace, no backtracking; comments on sampling_SC; removing own implementation of inference_SC call

diff --git a/src/slp.pl b/src/slp.pl
index 88d2372..9fba021 100644
--- a/src/slp.pl
+++ b/src/slp.pl
@@ -17,27 +17,9 @@ replace_left([NewL|TailNewL], [_=R|Tail], Res) :-
     nonvar(NewL),
     replace_left(TailNewL, [_=R|Tail], Res).
 
-% replacing ground atoms with free variables according to the unification pattern in UnifBag
-ground_to_var([], _, []).
-ground_to_var([GroundHead|GroundTail], UnifBag, [Var|VarListTail]) :-
-    member((Var=GroundHead), UnifBag),
-    ground_to_var(GroundTail, UnifBag, VarListTail).
-
 % transferring initial goal to list
 goal_to_list((G1, G2), [G1|GoalTail]) :- goal_to_list(G2, GoalTail).
 goal_to_list(G, [G]) :- G \= (_ , _).
-
-inference_SC_test(G, Prob) :-
-    G \= (_, _),
-    clause(_::G, _).
-
-inference_SC_test((G1, G2), Prob) :-
-    clause(_::G1, _),
-    inference_SC_test(G2, Prob),
-    % checking if variables are still free (e.g. X=X), then VarList won't be empty
-    %term_variables(G, VarList),
-    %( VarList \= [] -> writeln('true,'); true),
-    p((G1, G2), Prob).
     
 inference_SC(G, Prob) :-
     G \= (_, _),
@@ -107,70 +89,53 @@ replace(Subterm0, Subterm, Term0, Term) :-
             Term =.. [F|Args]
     ).
 
-collect_grounds(Goal, GoalsTail, Res).
-
-
-% idea behind free_bindings:
-% destructure input term iteratively, ultimately reaching every ground atom that needs to be replaced by a free variable
-% based on current term structure three processing methods:
-%   variables: no replacement required --> appending to result list as left-most element 
-%   ground atoms: replacement required -->
-%       appending atom to GroundList so that it gets replaced in the base case,
-%       retrieving corresponding free variable from FreeList and append it as left-most element to result list
-%   predicates: no replacement required --> 
-%       destructuring with =.. and calling recursion on its arguments
-%       reassembling predicate after all inner arguments have been processed
-%       adding predicate (now containing only free variables) as left-most element to result list
-%
-% obstacles: Same bindings must be replaced with same variables --> first collecting all bindings in list and only then replacing them 
-%
-% for compound goals: both depth and breadth recursion needed
-%   depth recursion: decomposing a single goal
-%   breadth recursion: recursively processing all subgoals, starting at the left-most
-%   second to last argument: list making up depth result
-%   last argument: list making up breadth result === overall result  
-
-% breadth and depth base case: replacing all ground atoms in Ground with free variables
-free_bindings([], [], GroundList, FreeList, [], []) :- 
-    % list_to_set to obtain same variable name for same binding
-    list_to_set(GroundList, GroundSet),
-    % for each ground atom in GroundSet get one fresh free variable
-    length(GroundSet, GroundLength),
-    length(FreeSet, GroundLength),
-    unifiable(FreeSet, GroundSet, UnifBag),
-    % change ground atoms to variables according to pairing in UnifBag
-    ground_to_var(GroundList, UnifBag, FreeList).
+replace_grounds(Term, [], [], Term) :- !. % no backtracking for base cases
+replace_grounds(Term, [GroundHead|GroundTail], [VarHead|VarTail], FreeTerm) :-
+    replace(GroundHead, VarHead, Term, ReplacedTerm),
+    replace_grounds(ReplacedTerm, GroundTail, VarTail, FreeTerm).
+
+% comment on cuts: prevent calling clauses further down when backtracking and therefore fail
+% breadth and depth base case: all subgoals of input goal have been processed
+collect_grounds([], [], []) :- !.
 % breadth recursion starting at depth base case:
-free_bindings([], [RemainingHead|RemainingTail], GroundList, FreeList, [], BreadthResList) :-
-    free_bindings([RemainingHead], RemainingTail, GroundList, FreeList, NewDepthResList, BreadthResList).
+collect_grounds([], [RemainingHead|RemainingTail], GroundList) :-
+    collect_grounds([RemainingHead], RemainingTail, GroundList),
+    !.
 % depth recursion: handling variables
-free_bindings([TermHead|TermTail], RemainingTerms, GroundList, FreeList, [TermHead|DepthResTail], BreadthResList) :-
-    % TermHead is a variable
-    var(TermHead),
-    free_bindings(TermTail, RemainingTerms, GroundList, FreeList, DepthResTail, BreadthResList).
+collect_grounds([SubGoalHead|SubGoalTail], RemainingGoals, GroundList) :-
+    % SubGoalHead is a variable --> ignored
+    var(SubGoalHead),
+    !,
+    collect_grounds(SubGoalTail, RemainingGoals, GroundList).
 % depth recursion: handling ground atoms
-free_bindings([TermHead|TermTail], RemainingTerms, GroundTail, FreeTail, [FreeHead|DepthResTail], BreadthResList) :-
-    % TermHead no variable (otherwise instantiation errors in =..)
-    nonvar(TermHead),
-    TermHead =.. [Functor|TList],
-    % TermHead is atomic and ground
-    TList = [],
-    free_bindings(TermTail, RemainingTerms, [Functor|GroundTail], [FreeHead|FreeTail], DepthResTail, BreadthResList).
+collect_grounds([SubGoalHead|SubGoalTail], RemainingGoals, [Functor|GroundTail]) :-
+    % SubGoalHead no variable as they were dealt with in previous clause (+!)
+    SubGoalHead =.. [Functor|Args],
+    % SubGoalHead is atomic and ground
+    Args = [],
+    !,
+    collect_grounds(SubGoalTail, RemainingGoals, GroundTail).
 % depth recursion: handling non-ground predicates
-% result is appended to overall result list in right-most argument
-free_bindings([TermHead|_], RemainingTerms, GroundList, FreeList, [Predicate], [Predicate|BreadthResTail]) :-
-    % TermHead no variable (otherwise instantiation errors in =..)
-    nonvar(TermHead),
-    TermHead =.. [Functor|TList],
-    % mutual exclusivity of clauses preventing false results via backtracking (e.g. for free_bindings([f(a)], [], _, Free))
-    TList \= [],
-    free_bindings(TList, RemainingTerms, GroundList, FreeList, DepthResTail, BreadthResTail),
-    Predicate =.. [Functor|DepthResTail].
+collect_grounds([SubGoalHead|_], RemainingGoals, GroundList) :-
+    % SubGoalHead no variable as they were dealt with in previous clause (+!)
+    SubGoalHead =.. [_|Args],
+    Args \= [],
+    collect_grounds(Args, RemainingGoals, GroundList).
+
+
+free_bindings(FirstSubGoal, RemainingGoals, FreeGoals) :-
+    collect_grounds(FirstSubGoal, RemainingGoals, GroundList),
+    % list_to_set to obtain same variable name for same binding
+    list_to_set(GroundList, GroundSet),
+    % for each ground atom in GroundSet get one fresh free variable
+    length(GroundSet, GroundLength),
+    length(VarSet, GroundLength),
+    replace_grounds([FirstSubGoal|RemainingGoals], GroundSet, VarSet, FreeGoals).
 
 
 p(G, RoundedResult) :-
     goal_to_list(G, [GHead|GTail]),
-    free_bindings([GHead], GTail, [], _, _, GFreeList),
+    free_bindings([GHead], GTail, GFreeList),
     goal_to_list(GFree, GFreeList),
     z(G, Numerator, _),
     z(GFree, Denominator, _),
@@ -292,8 +257,9 @@ z(G, Weight, Depth) :-
 % unconstrained (loglinear) sampling
 sample_UC(Head) :-
     findall([Prob::Head, Body], clause((Prob :: Head), Body), ClauseBag),
+    % probabilisticly choosing a clause in ClauseBag --> binding Head and Body
     random_clause(Head, Body, ClauseBag),
-    % we just sample once for now
+    % we just sample once for now, i.e. sticking to the choice of random_clause
     !,
     sample_UC(Body).
 
@@ -311,6 +277,7 @@ sample_UC(G) :-
 
 random_clause(Head, Body, ClauseBag) :-
     transform_probabilities(ClauseBag, ShiftedClauseBag),
+    % generating random float between 0 and 1
     Rand is random_float,
     choose(ShiftedClauseBag, Rand, [Head, Body]).
 
@@ -322,6 +289,7 @@ choose([[ShiftedProb::ShiftedHead, Body]|Tail], SampleProb, Sample) :-
 
 % shift the probabilities so we can sample from a uniform distribution
 % implicit failure/base case:
+% probability of failure === 1 - sum of probabilities for successful cases
 transform_probabilities([[P::H, B]], [[P::H, B], Failure]) :-
     % need a head with the same functor and arity, but all free variables as arguments
     functor(H, FailureName, FailureArity),
@@ -337,6 +305,7 @@ transform_probabilities([[P1::H1, B1],[P2::H2, B2]|Tail], L) :-
 
 sample_SC(Head) :-
     findall([Prob::Head, Body], clause((Prob :: Head), Body), ClauseBag),
+    % probabilisticly choosing a clause in ClauseBag --> binding Head and Body
     random_clause(Head, Body, ClauseBag),
     % Head + Body ground; bind Prob
     clause((Prob :: Head), Body),
@@ -345,8 +314,11 @@ sample_SC(Head) :-
     -> !
     % if we fail in the above, preprocess the tree, rewriting probabilities
     ;   writeln([Prob::Head, Body]),
+        % sum of clause probabilities with current Head without the failed clause Prob::Head :- Body
+        % recursively all failing clauses get removed --> sum decreasing continuously
         sum_remaining(ClauseBag, Prob, 0, Denominator),
         writeln(Denominator),
+        % rewrite probabilities of remaining clauses proportional to the successful branches
         change_prob(ClauseBag, [Prob::Head, Body], Denominator)
     ).
 
@@ -359,17 +331,18 @@ sample_SC(G) :-
     G.
 
 change_prob([], [_::_, _], _).
-% failure -> 0
+% failed clause Prob::Head :- Body -> 0 probability
 change_prob([[Prob::Head, Body]|BagTail], [Prob::Head, Body], Denominator) :-
     writeln([Prob::Head, Body]),
-    retract(Prob::Head :- Body),
+    retract(Prob::Head :- Body), % TODO: will it work for ground clauses, too?
     assertz(0::Head :- Body),
     change_prob(BagTail, [Prob::Head, Body], Denominator).
 % otherwise -> adjust
+% TODO: why no backtracking of failed case to this clause?
 change_prob([[P::H, B]|BagTail], [Prob::Head, Body], Denominator) :-
     writeln(BagTail),
     retract(P::H :- B),
-    round_third(P/Denominator, Rounded).
+    round_third(P/Denominator, Rounded),
     assertz(Rounded::H :- B),
     change_prob(BagTail, [Prob::Head, Body], Denominator).
 

commit 67254bdd1f9914e1a01175052b5cef08c4fbab79
Merge: 9d28ad8 26ca9ff
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Fri Sep 22 01:03:02 2023 +0200

    Merge branch 'master' of gitlab.lrz.de:000000000135D322/plp

commit 9d28ad8fdbdc165578a4c6869560f0836510afa6
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Fri Sep 22 01:02:58 2023 +0200

    test implementation of inference_SC

diff --git a/src/slp.pl b/src/slp.pl
index 31a5c91..74993fe 100644
--- a/src/slp.pl
+++ b/src/slp.pl
@@ -26,6 +26,18 @@ ground_to_var([GroundHead|GroundTail], UnifBag, [Var|VarListTail]) :-
 % transferring initial goal to list
 goal_to_list((G1, G2), [G1|GoalTail]) :- goal_to_list(G2, GoalTail).
 goal_to_list(G, [G]) :- G \= (_ , _).
+
+inference_SC_test(G, Prob) :-
+    G \= (_, _),
+    clause(_::G, _).
+
+inference_SC_test((G1, G2), Prob) :-
+    clause(_::G1, _),
+    inference_SC_test(G2, Prob),
+    % checking if variables are still free (e.g. X=X), then VarList won't be empty
+    %term_variables(G, VarList),
+    %( VarList \= [] -> writeln('true,'); true),
+    p((G1, G2), Prob).
     
 inference_SC(G, Prob) :-
     G \= (_, _),
@@ -318,6 +330,8 @@ transform_probabilities([[P1::H1, B1],[P2::H2, B2]|Tail], L) :-
 0.2 :: qq(a).
 0.1 :: qq(b).
 
+0.5 :: compound(X) :- p(X), q(X).
+
 0.2 :: f(b).
 0.6 :: f(X).
 0.2 :: f(X) :- fail.

commit 26ca9fff14898441206322474961cee5b1e6406d
Author: mxs <mxs@dismail.de>
Date:   Thu Sep 21 20:34:01 2023 +0200

    backtrackable sampling works! (tested for simple case)

diff --git a/src/slp.pl b/src/slp.pl
index e81e30c..d9aadef 100644
--- a/src/slp.pl
+++ b/src/slp.pl
@@ -326,11 +326,15 @@ transform_probabilities([[P1::H1, B1],[P2::H2, B2]|Tail], L) :-
 sample_SC(Head) :-
     findall([Prob::Head, Body], clause((Prob :: Head), Body), ClauseBag),
     random_clause(Head, Body, ClauseBag),
+    % Head + Body ground; bind Prob
+    clause((Prob :: Head), Body),
     !,
     ( sample_SC(Body)
     -> !
     % if we fail in the above, preprocess the tree, rewriting probabilities
-    ;   sum_remaining(ClauseBag, [Prob::Head, Body], Denominator),
+    ;   writeln([Prob::Head, Body]),
+        sum_remaining(ClauseBag, Prob, 0, Denominator),
+        writeln(Denominator),
         change_prob(ClauseBag, [Prob::Head, Body], Denominator)
     ).
 
@@ -342,11 +346,67 @@ sample_SC((G1, G2)) :-
 sample_SC(G) :-
     G.
 
+change_prob([], [_::_, _], _).
+% failure -> 0
+change_prob([[Prob::Head, Body]|BagTail], [Prob::Head, Body], Denominator) :-
+    writeln([Prob::Head, Body]),
+    retract(Prob::Head :- Body),
+    assertz(0::Head :- Body),
+    change_prob(BagTail, [Prob::Head, Body], Denominator).
+% otherwise -> adjust
+change_prob([[P::H, B]|BagTail], [Prob::Head, Body], Denominator) :-
+    writeln(BagTail),
+    retract(P::H :- B),
+    round_third(P/Denominator, Rounded).
+    assertz(Rounded::H :- B),
+    change_prob(BagTail, [Prob::Head, Body], Denominator).
+
+sum_remaining([], FailedP, Akk, Denominator) :-
+    Denominator is Akk - FailedP.
+sum_remaining([[P::_, _]|BagTail], FailedP, Akk, Denominator) :-
+    Akknew is Akk + P,
+    sum_remaining(BagTail, FailedP, Akknew, Denominator).
+
 % p(X) :- q1(X), q2(X).
 % q1(a).
 % q2(X) :- fail.
 
 % TESTS
+
+% sample_SC tree rewriting test:
+% have:
+% ├───½
+% │   ├───⅓
+% │   │   ├───½─⊸ fail             -> ¹⁄₁₂
+% │   │   └───½─⊸                  -> ¹⁄₁₂
+% │   ├───⅓─⊸ fail                -> ⅙
+% │   └───⅓─⊸                     -> ⅙
+% └───½─⊸                          -> ½
+% want:
+% ├───½
+% │   ├───½
+% │   │   ├───0─⊸ fail             -> 0
+% │   │   └───1─⊸                  -> ¼
+% │   ├───0─⊸ fail                 -> 0
+% │   └───½─⊸                      -> ¼
+% └───½─⊸                          -> ½
+1/2 :: ssct0.
+1/2 :: ssct0 :- ssct1.
+1/3 :: ssct1 :- fail.
+1/3 :: ssct1.
+1/3 :: ssct1 :- ssct2.
+1/2 :: ssct2 :- fail.
+1/2 :: ssct2.
+% after hitting fail twice:
+% 1/2 :: ssct0.
+% 1/2 :: ssct0 :- ssct1.
+% 0 :: ssct1 :- fail.
+% 1/3/0.6666666666666667 (===0.49) :: ssct1.
+% 1/3/0.6666666666666667 (===0.49) :: ssct1 :- ssct2.
+% 0 :: ssct2 :- fail.
+% 1/2/0.5 (===1) :: ssct2.
+
+
 % want: z((q(X), p(X)), W) === 0.46
 0.6 :: p(a).
 0.4 :: p(b).

commit 6716c95c58dc8296fc1272e6441724a2f812e2ec
Author: mxs <mxs@dismail.de>
Date:   Thu Sep 21 15:39:50 2023 +0200

    wip

diff --git a/src/demo_doc.pl b/src/demo_doc.pl
index 0e90de1..8f3bb30 100644
--- a/src/demo_doc.pl
+++ b/src/demo_doc.pl
@@ -1,15 +1,18 @@
 % TODO
-% -  inference_marginal(qq(X),P). ---> P = [[X=X, 0.6], [X=a, 0.2]] ; (should be 0.8)
-% - constrained sampling
-% - demo / tests
-% - cuts
-% - code organisation / refactor
-% - improving output of marginal and remove type error (Weight can be float in SC case or List of Lists in marginal case)
-% - compound assert/retract inference_SC
-% - splitting for marginal
-% - err if a functor's labels sum to >1'
-% - special sampling mit SC inference
-% - st(qq(X)) : (nested functors) inference, sampling
+% R free_bindings umschreiben für replace
+% R inference_marginal(qq(X),P). ---> P = [[X=X, 0.6], [X=a, 0.2]] ; (should be 0.8)
+% M constrained sampling
+% R demo / tests
+% M cuts
+% M code organisation / refactor
+% R improving output of marginal and remove type error (Weight can be float in SC case or List of Lists in marginal case)
+% M compound assert/retract inference_SC
+% R p zero divisor
+% R theta splitting for marginal
+% M err if a functor's labels sum to >1'
+% M special sampling mit SC inference
+
+% - nested functors: st(qq(X)) : inference, sampling
 % - impure
 % - disjunction
 
@@ -31,6 +34,8 @@
 1/2 :: sst3(b).
 1/2 :: sst3(c).
 
+
+
 % --------------------
 
 % inference: marginal
diff --git a/src/slp.pl b/src/slp.pl
index 31a5c91..e81e30c 100644
--- a/src/slp.pl
+++ b/src/slp.pl
@@ -31,21 +31,32 @@ inference_SC(G, Prob) :-
     G \= (_, _),
     clause(_::G, _),
     % checking if variables are still free (e.g. X=X), then VarList won't be empty
+    writeln('xxx'),
     term_variables(G, VarList),
+    writeln('<<'),
     ( VarList \= [] -> writeln('true,'); true),
-    p(G, Prob).
+    writeln('sdfsd'),
+    p(G, Prob),
+    writeln('aaaaaaaaaaaa').
 
-% TODO: retract fails, therefore inference_SC fails
+% doesnt work for ground goals:
+% inference_SC((q(a), p(a)), P).
 inference_SC((G1,G2), Prob) :-
     gensym(reserved_newgoal, X),
     term_variables((G1, G2), VarList),
+    writeln('aaa'),
     NewHead =.. [X|VarList],
-    writeln(1::NewHead),
+    writeln('bbb'),
     assertz((1::NewHead :- (G1, G2))),
+    writeln('ccc'),
     inference_SC(NewHead, Prob),
-    !,
+    writeln('ddd'),
     writeln(1::NewHead),
-    retract(1::NewHead).
+    ( VarList = [] ->
+        retract(1::NewHead) ;
+        % https://stackoverflow.com/a/55948034
+        retract((1::NewHead :- (G1, G2)))
+    ).
 
 % example call: inference_marginal((s(X,Y),r(Y,Z)), Prob)
 % in the general case, one Variable (TODO: which?) is not part of the list in Weight but rather detemined by backtracking
@@ -75,13 +86,18 @@ inference_marginal(Goal, ProbList) :-
 % https://stackoverflow.com/questions/37260614/prolog-replacing-subterms/53145013#53145013
 % replacee | replacement | term | res
 replace(Subterm0, Subterm, Term0, Term) :-
-    (   Term0 == Subterm0 -> Term = Subterm
-    ;   var(Term0) -> Term = Term0
-    ;   Term0 =.. [F|Args0],
-        maplist(replace(Subterm0,Subterm), Args0, Args),
-        Term =.. [F|Args]
+    (Term0 == Subterm0
+        -> Term = Subterm
+        ; var(Term0)
+            -> Term = Term0
+            ; Term0 =.. [F|Args0],
+            maplist(replace(Subterm0,Subterm), Args0, Args),
+            Term =.. [F|Args]
     ).
 
+collect_grounds(Goal, GoalsTail, Res).
+
+
 % idea behind free_bindings:
 % destructure input term iteratively, ultimately reaching every ground atom that needs to be replaced by a free variable
 % based on current term structure three processing methods:
@@ -305,6 +321,30 @@ transform_probabilities([[P1::H1, B1],[P2::H2, B2]|Tail], L) :-
     transform_probabilities([[TransfromedProb::H2, B2]|Tail], TempL),
     L = [[P1::H1, B1]|TempL].
 
+%-----
+
+sample_SC(Head) :-
+    findall([Prob::Head, Body], clause((Prob :: Head), Body), ClauseBag),
+    random_clause(Head, Body, ClauseBag),
+    !,
+    ( sample_SC(Body)
+    -> !
+    % if we fail in the above, preprocess the tree, rewriting probabilities
+    ;   sum_remaining(ClauseBag, [Prob::Head, Body], Denominator),
+        change_prob(ClauseBag, [Prob::Head, Body], Denominator)
+    ).
+
+% compound body
+sample_SC((G1, G2)) :-
+    sample_SC(G1),
+    sample_SC(G2).
+
+sample_SC(G) :-
+    G.
+
+% p(X) :- q1(X), q2(X).
+% q1(a).
+% q2(X) :- fail.
 
 % TESTS
 % want: z((q(X), p(X)), W) === 0.46
@@ -322,11 +362,17 @@ transform_probabilities([[P1::H1, B1],[P2::H2, B2]|Tail], L) :-
 0.6 :: f(X).
 0.2 :: f(X) :- fail.
 
+% XXX: p(cmp1(b), P). -> zero divisor
+0.5 :: cmp1(X, Y) :- qq(X), qq(Y).
+
+0.5 :: cmp(X) :- p(X), q(X).
+
 0.1 :: st(a, b).
 0.9 :: st(X, b) :- fail.
 
 0.7 :: s(X, b) :- q(X).
 0.1 :: s(a, c).
-0.2 :: s(b, b).
+0.1 :: s(b, b).
+0.05 :: s(b, a).
 0.2 :: r(b, Z) :- p(Z).
-0.8 :: r(a, b).
+0.7 :: r(a, b).

commit 3c6bd21b9e00c5fce59f9e28f905575411deded5
Author: mxs <mxs@dismail.de>
Date:   Thu Sep 21 12:43:12 2023 +0200

    wip: compound inference_SC

diff --git a/src/demo_doc.pl b/src/demo_doc.pl
index 172da4a..0e90de1 100644
--- a/src/demo_doc.pl
+++ b/src/demo_doc.pl
@@ -5,9 +5,11 @@
 % - cuts
 % - code organisation / refactor
 % - improving output of marginal and remove type error (Weight can be float in SC case or List of Lists in marginal case)
+% - compound assert/retract inference_SC
 % - splitting for marginal
 % - err if a functor's labels sum to >1'
 % - special sampling mit SC inference
+% - st(qq(X)) : (nested functors) inference, sampling
 % - impure
 % - disjunction
 
diff --git a/src/slp.pl b/src/slp.pl
index 16974fc..31a5c91 100644
--- a/src/slp.pl
+++ b/src/slp.pl
@@ -27,6 +27,26 @@ ground_to_var([GroundHead|GroundTail], UnifBag, [Var|VarListTail]) :-
 goal_to_list((G1, G2), [G1|GoalTail]) :- goal_to_list(G2, GoalTail).
 goal_to_list(G, [G]) :- G \= (_ , _).
     
+inference_SC(G, Prob) :-
+    G \= (_, _),
+    clause(_::G, _),
+    % checking if variables are still free (e.g. X=X), then VarList won't be empty
+    term_variables(G, VarList),
+    ( VarList \= [] -> writeln('true,'); true),
+    p(G, Prob).
+
+% TODO: retract fails, therefore inference_SC fails
+inference_SC((G1,G2), Prob) :-
+    gensym(reserved_newgoal, X),
+    term_variables((G1, G2), VarList),
+    NewHead =.. [X|VarList],
+    writeln(1::NewHead),
+    assertz((1::NewHead :- (G1, G2))),
+    inference_SC(NewHead, Prob),
+    !,
+    writeln(1::NewHead),
+    retract(1::NewHead).
+
 % example call: inference_marginal((s(X,Y),r(Y,Z)), Prob)
 % in the general case, one Variable (TODO: which?) is not part of the list in Weight but rather detemined by backtracking
 inference_marginal(Goal, ProbList) :-
@@ -51,14 +71,16 @@ inference_marginal(Goal, ProbList) :-
 %   G is non-compound; TODO: assert user input as clause and retract later
 %   ArgList contains the instantiated parameters for G
 
-% https://stackoverflow.com/questions/12638347/replace-atom-with-variable
+% TODO: maybe this is better than our approach for replacing ground atoms with variables
 % https://stackoverflow.com/questions/37260614/prolog-replacing-subterms/53145013#53145013
-% https://stackoverflow.com/questions/22812691/prolog-replace-each-instance-of-a-constant-in-a-list-with-a-variable
-
-% for every ground element in GroundList return a new free variable
-as_vars([], []).
-as_vars([_|GroundTail], [_|VarsTail]) :-
-    as_vars(GroundTail, VarsTail).
+% replacee | replacement | term | res
+replace(Subterm0, Subterm, Term0, Term) :-
+    (   Term0 == Subterm0 -> Term = Subterm
+    ;   var(Term0) -> Term = Term0
+    ;   Term0 =.. [F|Args0],
+        maplist(replace(Subterm0,Subterm), Args0, Args),
+        Term =.. [F|Args]
+    ).
 
 % idea behind free_bindings:
 % destructure input term iteratively, ultimately reaching every ground atom that needs to be replaced by a free variable
@@ -85,7 +107,8 @@ free_bindings([], [], GroundList, FreeList, [], []) :-
     % list_to_set to obtain same variable name for same binding
     list_to_set(GroundList, GroundSet),
     % for each ground atom in GroundSet get one fresh free variable
-    as_vars(GroundSet, FreeSet),
+    length(GroundSet, GroundLength),
+    length(FreeSet, GroundLength),
     unifiable(FreeSet, GroundSet, UnifBag),
     % change ground atoms to variables according to pairing in UnifBag
     ground_to_var(GroundList, UnifBag, FreeList).
@@ -293,7 +316,7 @@ transform_probabilities([[P1::H1, B1],[P2::H2, B2]|Tail], L) :-
 
 0.6 :: qq(X).
 0.2 :: qq(a).
-% 0.1 :: qq(b).
+0.1 :: qq(b).
 
 0.2 :: f(b).
 0.6 :: f(X).

commit ce6fec0d12c19357160d9340b6a655638b63cb25
Author: mxs <mxs@dismail.de>
Date:   Thu Sep 21 11:40:28 2023 +0200

    todo (marginal inf bug) + comments + remove unnecessary list_to_goal

diff --git a/src/demo_doc.pl b/src/demo_doc.pl
index 7daf70b..172da4a 100644
--- a/src/demo_doc.pl
+++ b/src/demo_doc.pl
@@ -1,5 +1,5 @@
 % TODO
-% - p/2 implementation (compound?)
+% -  inference_marginal(qq(X),P). ---> P = [[X=X, 0.6], [X=a, 0.2]] ; (should be 0.8)
 % - constrained sampling
 % - demo / tests
 % - cuts
diff --git a/src/slp.pl b/src/slp.pl
index bc3edcd..16974fc 100644
--- a/src/slp.pl
+++ b/src/slp.pl
@@ -1,5 +1,6 @@
 :- op(1199,xfx,::).
 :- discontiguous (::)/2.
+:- dynamic (::)/2.
 
 % meta-assumptions:
 %   only conjunctions
@@ -25,12 +26,6 @@ ground_to_var([GroundHead|GroundTail], UnifBag, [Var|VarListTail]) :-
 % transferring initial goal to list
 goal_to_list((G1, G2), [G1|GoalTail]) :- goal_to_list(G2, GoalTail).
 goal_to_list(G, [G]) :- G \= (_ , _).
-
-% transferring free goal list to goal
-% TODO: correct list_to_goal implementation
-list_to_goal(G, (GHead)) :- [GHead|NoTail] = G, NoTail=[].
-list_to_goal([G1|GTail], (G1, GTailNew)) :- list_to_goal(GTail, GTailNew).
-
     
 % example call: inference_marginal((s(X,Y),r(Y,Z)), Prob)
 % in the general case, one Variable (TODO: which?) is not part of the list in Weight but rather detemined by backtracking
@@ -242,6 +237,7 @@ z(G, Weight, Depth) :-
 % backtrackable: hier implementieren
 % importance: wahrscheinlich ein improvement zum improved loglinear
 
+% TODO: what is the expected result for sampling a goal that doesn't exist?
 % unconstrained (loglinear) sampling
 sample_UC(Head) :-
     findall([Prob::Head, Body], clause((Prob :: Head), Body), ClauseBag),
@@ -260,7 +256,7 @@ sample_UC((G1, G2)) :-
 sample_UC(G) :-
     % writeln(G),
     !,
-    G.
+    G. % executes "fail" when encountering failure, making sure we don't get spurious bindings through backtracking.
 
 random_clause(Head, Body, ClauseBag) :-
     transform_probabilities(ClauseBag, ShiftedClauseBag),
@@ -297,7 +293,7 @@ transform_probabilities([[P1::H1, B1],[P2::H2, B2]|Tail], L) :-
 
 0.6 :: qq(X).
 0.2 :: qq(a).
-0.1 :: qq(b).
+% 0.1 :: qq(b).
 
 0.2 :: f(b).
 0.6 :: f(X).

commit 2ee03385563927adf1750b4d0af49af46a95cb32
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Thu Sep 21 11:33:42 2023 +0200

    different representation for GFreeList in free_bindings, list to goal transformation before applying z

diff --git a/src/slp.pl b/src/slp.pl
index 2c2fe01..bc3edcd 100644
--- a/src/slp.pl
+++ b/src/slp.pl
@@ -112,7 +112,7 @@ free_bindings([TermHead|TermTail], RemainingTerms, GroundTail, FreeTail, [FreeHe
     free_bindings(TermTail, RemainingTerms, [Functor|GroundTail], [FreeHead|FreeTail], DepthResTail, BreadthResList).
 % depth recursion: handling non-ground predicates
 % result is appended to overall result list in right-most argument
-free_bindings([TermHead|_], RemainingTerms, GroundList, FreeList, [Predicate], [[Predicate]|BreadthResTail]) :-
+free_bindings([TermHead|_], RemainingTerms, GroundList, FreeList, [Predicate], [Predicate|BreadthResTail]) :-
     % TermHead no variable (otherwise instantiation errors in =..)
     nonvar(TermHead),
     TermHead =.. [Functor|TList],
@@ -125,7 +125,7 @@ free_bindings([TermHead|_], RemainingTerms, GroundList, FreeList, [Predicate], [
 p(G, RoundedResult) :-
     goal_to_list(G, [GHead|GTail]),
     free_bindings([GHead], GTail, [], _, _, GFreeList),
-    list_to_goal(GFreeList, GFree),
+    goal_to_list(GFree, GFreeList),
     z(G, Numerator, _),
     z(GFree, Denominator, _),
     Result is Numerator / Denominator,

commit 8184348f819171afef9ea4366b87d28131cf54f0
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Thu Sep 21 10:13:10 2023 +0200

    free_bindings works for compound goals; TODO: list_to_goal implementation

diff --git a/src/slp.pl b/src/slp.pl
index 459f282..2c2fe01 100644
--- a/src/slp.pl
+++ b/src/slp.pl
@@ -26,6 +26,11 @@ ground_to_var([GroundHead|GroundTail], UnifBag, [Var|VarListTail]) :-
 goal_to_list((G1, G2), [G1|GoalTail]) :- goal_to_list(G2, GoalTail).
 goal_to_list(G, [G]) :- G \= (_ , _).
 
+% transferring free goal list to goal
+% TODO: correct list_to_goal implementation
+list_to_goal(G, (GHead)) :- [GHead|NoTail] = G, NoTail=[].
+list_to_goal([G1|GTail], (G1, GTailNew)) :- list_to_goal(GTail, GTailNew).
+
     
 % example call: inference_marginal((s(X,Y),r(Y,Z)), Prob)
 % in the general case, one Variable (TODO: which?) is not part of the list in Weight but rather detemined by backtracking
@@ -72,10 +77,16 @@ as_vars([_|GroundTail], [_|VarsTail]) :-
 %       reassembling predicate after all inner arguments have been processed
 %       adding predicate (now containing only free variables) as left-most element to result list
 %
-% obstacles: Same bindings must be replaced with same variables --> first collecting all bindings in list and only then replacing them   
-
-% base case: replacing all ground atoms in Ground with free variables
-free_bindings([], GroundList, FreeList, []) :- 
+% obstacles: Same bindings must be replaced with same variables --> first collecting all bindings in list and only then replacing them 
+%
+% for compound goals: both depth and breadth recursion needed
+%   depth recursion: decomposing a single goal
+%   breadth recursion: recursively processing all subgoals, starting at the left-most
+%   second to last argument: list making up depth result
+%   last argument: list making up breadth result === overall result  
+
+% breadth and depth base case: replacing all ground atoms in Ground with free variables
+free_bindings([], [], GroundList, FreeList, [], []) :- 
     % list_to_set to obtain same variable name for same binding
     list_to_set(GroundList, GroundSet),
     % for each ground atom in GroundSet get one fresh free variable
@@ -83,33 +94,38 @@ free_bindings([], GroundList, FreeList, []) :-
     unifiable(FreeSet, GroundSet, UnifBag),
     % change ground atoms to variables according to pairing in UnifBag
     ground_to_var(GroundList, UnifBag, FreeList).
-% handling variables
-free_bindings([TermHead|TermTail], GroundList, FreeList, [TermHead|ResListTail]) :-
+% breadth recursion starting at depth base case:
+free_bindings([], [RemainingHead|RemainingTail], GroundList, FreeList, [], BreadthResList) :-
+    free_bindings([RemainingHead], RemainingTail, GroundList, FreeList, NewDepthResList, BreadthResList).
+% depth recursion: handling variables
+free_bindings([TermHead|TermTail], RemainingTerms, GroundList, FreeList, [TermHead|DepthResTail], BreadthResList) :-
     % TermHead is a variable
     var(TermHead),
-    free_bindings(TermTail, GroundList, FreeList, ResListTail).
-% handling ground atoms
-free_bindings([TermHead|TermTail], GroundTail, FreeTail, [FreeHead|ResTail]) :-
+    free_bindings(TermTail, RemainingTerms, GroundList, FreeList, DepthResTail, BreadthResList).
+% depth recursion: handling ground atoms
+free_bindings([TermHead|TermTail], RemainingTerms, GroundTail, FreeTail, [FreeHead|DepthResTail], BreadthResList) :-
     % TermHead no variable (otherwise instantiation errors in =..)
     nonvar(TermHead),
     TermHead =.. [Functor|TList],
     % TermHead is atomic and ground
     TList = [],
-    free_bindings(TermTail, [Functor|GroundTail], [FreeHead|FreeTail], ResTail).
-% handling non-ground predicates
-free_bindings([TermHead|_], GroundList, FreeList, [Predicate]) :-
+    free_bindings(TermTail, RemainingTerms, [Functor|GroundTail], [FreeHead|FreeTail], DepthResTail, BreadthResList).
+% depth recursion: handling non-ground predicates
+% result is appended to overall result list in right-most argument
+free_bindings([TermHead|_], RemainingTerms, GroundList, FreeList, [Predicate], [[Predicate]|BreadthResTail]) :-
     % TermHead no variable (otherwise instantiation errors in =..)
     nonvar(TermHead),
     TermHead =.. [Functor|TList],
     % mutual exclusivity of clauses preventing false results via backtracking (e.g. for free_bindings([f(a)], [], _, Free))
     TList \= [],
-    free_bindings(TList, GroundList, FreeList, ResListTail),
-    Predicate =.. [Functor|ResListTail].
+    free_bindings(TList, RemainingTerms, GroundList, FreeList, DepthResTail, BreadthResTail),
+    Predicate =.. [Functor|DepthResTail].
 
 
 p(G, RoundedResult) :-
-    goal_to_list(G, GList),
-    free_bindings(GList, [], _, [GFree]),
+    goal_to_list(G, [GHead|GTail]),
+    free_bindings([GHead], GTail, [], _, _, GFreeList),
+    list_to_goal(GFreeList, GFree),
     z(G, Numerator, _),
     z(GFree, Denominator, _),
     Result is Numerator / Denominator,
@@ -283,9 +299,6 @@ transform_probabilities([[P1::H1, B1],[P2::H2, B2]|Tail], L) :-
 0.2 :: qq(a).
 0.1 :: qq(b).
 
-5/10 :: qq(a).
-3/10 :: qq(b).
-
 0.2 :: f(b).
 0.6 :: f(X).
 0.2 :: f(X) :- fail.

commit 4f8bcd7b278c2603383bf0dc9c742f691ef25248
Merge: abed7fc c9d42bc
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Thu Sep 21 08:16:26 2023 +0200

    Merge branch 'master' of gitlab.lrz.de:000000000135D322/plp

commit abed7fc98711ca2687fcd5d4bc40f4539e1232e0
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Thu Sep 21 08:16:19 2023 +0200

    transferring input goal to list to free compound goals as well

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 4e609f0..a3bd6ba 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -22,6 +22,10 @@ ground_to_var([GroundHead|GroundTail], UnifBag, [Var|VarListTail]) :-
     member((Var=GroundHead), UnifBag),
     ground_to_var(GroundTail, UnifBag, VarListTail).
 
+% transferring initial goal to list
+goal_to_list((G1, G2), [G1|GoalTail]) :- goal_to_list(G2, GoalTail).
+goal_to_list(G, [G]) :- G \= (_ , _).
+
     
 % example call: inference_marginal((s(X,Y),r(Y,Z)), Prob)
 % in the general case, one Variable (TODO: which?) is not part of the list in Weight but rather detemined by backtracking
@@ -104,8 +108,8 @@ free_bindings([TermHead|_], GroundList, FreeList, [Predicate]) :-
 
 
 p(G, RoundedResult) :-
-    %as_vars(G, GFree),
-    free_bindings([G], [], _, [GFree]),
+    goal_to_list(G, GList),
+    free_bindings(GList, [], _, [GFree]),
     z(G, Numerator, _),
     z(GFree, Denominator, _),
     Result is Numerator / Denominator,

commit c9d42bc73d923ce5aed1e919326acc05e781d20c
Author: mxs <mxs@dismail.de>
Date:   Thu Sep 21 00:33:55 2023 +0200

    sampling_UC: comment base case

diff --git a/src/slp.pl b/src/slp.pl
index 95c3241..b64906b 100644
--- a/src/slp.pl
+++ b/src/slp.pl
@@ -236,10 +236,9 @@ sample_UC((G1, G2)) :-
     sample_UC(G1),
     sample_UC(G2).
 
-% impure SLP case?
+% base case: true or fail. returns "false" when encountering fail
 sample_UC(G) :-
-    %\+clause((Prob :: G), _),
-    writeln(G),
+    % writeln(G),
     !,
     G.
 

commit 4cb4f4fcd5ac6299025bcb77ad0be90bf05e7737
Author: mxs <mxs@dismail.de>
Date:   Thu Sep 21 00:28:24 2023 +0200

    edit todo

diff --git a/src/demo_doc.pl b/src/demo_doc.pl
index 0571ddc..7daf70b 100644
--- a/src/demo_doc.pl
+++ b/src/demo_doc.pl
@@ -1,13 +1,13 @@
 % TODO
-% - p/2 implementation
-% - special sampling mit SC inference
+% - p/2 implementation (compound?)
 % - constrained sampling
+% - demo / tests
 % - cuts
 % - code organisation / refactor
-% - unconstrained sampling (ohne inference call)
 % - improving output of marginal and remove type error (Weight can be float in SC case or List of Lists in marginal case)
 % - splitting for marginal
 % - err if a functor's labels sum to >1'
+% - special sampling mit SC inference
 % - impure
 % - disjunction
 

commit 8d2ec6ddaf390de742d72c6b3ed54bbf8a2d9964
Author: mxs <mxs@dismail.de>
Date:   Thu Sep 21 00:24:57 2023 +0200

    sample -> sample_UC, cussens-inference.pl -> slp.pl, delete obsolete sampling.pl, metainterp.pl -> v1.pl

diff --git a/src/sampling.pl b/src/sampling.pl
deleted file mode 100644
index cfe0fc5..0000000
--- a/src/sampling.pl
+++ /dev/null
@@ -1,30 +0,0 @@
-% compound body
-sample((G1, G2)) :-
-    !,
-    sample(G1),
-    sample(G2).
-
-% Should this case really be a subclause of sample or does it rather belong to the (toplevel) metainterpreter
-sample(G) :-
-    \+clause((Prob :: G), _),
-    !,
-    G.
-
-sample(Head) :-
-    findall([Prob, Head, Body], clause((Prob :: Head), Body), Bag),
-    random_clause(Head, Body, Bag),
-    !,
-    sample(Body).
-
-% probabilistic clause selector
-random_clause(Head, Body, Bag) :-
-    Rand is random_float,
-    choose(Bag, Head, Body, 0, Rand, Sum).
-choose([], _, _, _, _, 0).
-choose([[Prob, Head, Body]|Tail], Head1, Body1, Akk, Rand, Rest) :-
-    Akknew is Akk + Prob,
-    choose(Tail, Head1, Body1, Akknew, Rand, Rest1),
-    Rest is Rest1 + Prob,
-    ((var(Body1),
-        Prob1 is Akk/(Akk+Rest), Rand >= Prob1, Head1 = Head, Body1 = Body);
-    true).
diff --git a/src/cussens-inference.pl b/src/slp.pl
similarity index 99%
rename from src/cussens-inference.pl
rename to src/slp.pl
index b17a934..95c3241 100644
--- a/src/cussens-inference.pl
+++ b/src/slp.pl
@@ -223,21 +223,21 @@ z(G, Weight, Depth) :-
 % importance: wahrscheinlich ein improvement zum improved loglinear
 
 % unconstrained (loglinear) sampling
-sample(Head) :-
+sample_UC(Head) :-
     findall([Prob::Head, Body], clause((Prob :: Head), Body), ClauseBag),
     random_clause(Head, Body, ClauseBag),
     % we just sample once for now
     !,
-    sample(Body).
+    sample_UC(Body).
 
 % compound body
-sample((G1, G2)) :-
+sample_UC((G1, G2)) :-
     !,
-    sample(G1),
-    sample(G2).
+    sample_UC(G1),
+    sample_UC(G2).
 
 % impure SLP case?
-sample(G) :-
+sample_UC(G) :-
     %\+clause((Prob :: G), _),
     writeln(G),
     !,
diff --git a/src/metainterp.pl b/src/v1.pl
similarity index 100%
rename from src/metainterp.pl
rename to src/v1.pl

commit 0005e1ef6d6d91c13a9a0f39a833e7ff1ed0651f
Author: mxs <mxs@dismail.de>
Date:   Thu Sep 21 00:18:07 2023 +0200

    loglinear sampling

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 4e609f0..b17a934 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -217,6 +217,57 @@ z(G, Weight, Depth) :-
     findall([Prob, G, Body], clause((Prob :: G), Body), UnifSet),
     unifSet_rec(G, true, UnifSet, Weight, Depth).
 
+% loglinear: ähnlich zum v1, nur ohne inference call
+% unification-constrained: in der effizienz zwischen loglinear und backtrackable
+% backtrackable: hier implementieren
+% importance: wahrscheinlich ein improvement zum improved loglinear
+
+% unconstrained (loglinear) sampling
+sample(Head) :-
+    findall([Prob::Head, Body], clause((Prob :: Head), Body), ClauseBag),
+    random_clause(Head, Body, ClauseBag),
+    % we just sample once for now
+    !,
+    sample(Body).
+
+% compound body
+sample((G1, G2)) :-
+    !,
+    sample(G1),
+    sample(G2).
+
+% impure SLP case?
+sample(G) :-
+    %\+clause((Prob :: G), _),
+    writeln(G),
+    !,
+    G.
+
+random_clause(Head, Body, ClauseBag) :-
+    transform_probabilities(ClauseBag, ShiftedClauseBag),
+    Rand is random_float,
+    choose(ShiftedClauseBag, Rand, [Head, Body]).
+
+choose([], _, false).
+choose([[ShiftedProb::ShiftedHead, Body]|Tail], SampleProb, Sample) :-
+    ( ShiftedProb >= SampleProb
+    -> Sample = [ShiftedHead, Body]
+    ; choose(Tail, SampleProb, Sample)).
+
+% shift the probabilities so we can sample from a uniform distribution
+% implicit failure/base case:
+transform_probabilities([[P::H, B]], [[P::H, B], Failure]) :-
+    % need a head with the same functor and arity, but all free variables as arguments
+    functor(H, FailureName, FailureArity),
+    length(K, FailureArity),
+    FailureH =.. [FailureName|K],
+    Failure = [1-P::FailureH, fail].
+transform_probabilities([[P1::H1, B1],[P2::H2, B2]|Tail], L) :-
+    TransfromedProb is P1 + P2,
+    transform_probabilities([[TransfromedProb::H2, B2]|Tail], TempL),
+    L = [[P1::H1, B1]|TempL].
+
+
 % TESTS
 % want: z((q(X), p(X)), W) === 0.46
 0.6 :: p(a).
diff --git a/src/demo_doc.pl b/src/demo_doc.pl
index a71b61f..0571ddc 100644
--- a/src/demo_doc.pl
+++ b/src/demo_doc.pl
@@ -3,10 +3,13 @@
 % - special sampling mit SC inference
 % - constrained sampling
 % - cuts
-% - code organisation / refactor marginal-SC
+% - code organisation / refactor
 % - unconstrained sampling (ohne inference call)
 % - improving output of marginal and remove type error (Weight can be float in SC case or List of Lists in marginal case)
 % - splitting for marginal
+% - err if a functor's labels sum to >1'
+% - impure
+% - disjunction
 
 0.6 :: q(X).
 0.2 :: q(a).

commit 2ea7d31c6de557211acaaf8f02a3f95c1cade3ae
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Wed Sep 20 20:57:23 2023 +0200

    p works not for compound goals, i.e. conjunctions

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index db61ef4..4e609f0 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -14,7 +14,14 @@ replace_left([NewL|TailNewL], [_=R|Tail], [NewL=R|Res]) :-
 % ignoring already globally bound variables s.t. lenght of binding list [_=R|Tail] equals list of new lefts [NewL|TailNewL]
 replace_left([NewL|TailNewL], [_=R|Tail], Res) :-
     nonvar(NewL),
-    replace_left(TailNewL, [_=R|Tail], Res).                
+    replace_left(TailNewL, [_=R|Tail], Res).
+
+% replacing ground atoms with free variables according to the unification pattern in UnifBag
+ground_to_var([], _, []).
+ground_to_var([GroundHead|GroundTail], UnifBag, [Var|VarListTail]) :-
+    member((Var=GroundHead), UnifBag),
+    ground_to_var(GroundTail, UnifBag, VarListTail).
+
     
 % example call: inference_marginal((s(X,Y),r(Y,Z)), Prob)
 % in the general case, one Variable (TODO: which?) is not part of the list in Weight but rather detemined by backtracking
@@ -40,42 +47,53 @@ inference_marginal(Goal, ProbList) :-
 %   G is non-compound; TODO: assert user input as clause and retract later
 %   ArgList contains the instantiated parameters for G
 
-% want p(f(b), P)
-% -> p(f(X), [X=b], P).
-p(G, ArgList, RoundedResult) :-
-    copy_term(G, GFree),
-    unify_helper(G, ArgList),
-    z(G, Numerator, _),
-    z(GFree, Denominator, _),
-    Result is Numerator / Denominator,
-    round_third(Result, RoundedResult).
-
-% ---WIP---
-
 % https://stackoverflow.com/questions/12638347/replace-atom-with-variable
 % https://stackoverflow.com/questions/37260614/prolog-replacing-subterms/53145013#53145013
 % https://stackoverflow.com/questions/22812691/prolog-replace-each-instance-of-a-constant-in-a-list-with-a-variable
 
+% for every ground element in GroundList return a new free variable
 as_vars([], []).
 as_vars([_|GroundTail], [_|VarsTail]) :-
     as_vars(GroundTail, VarsTail).
 
-% replacing all ground atoms in Ground with free variables
-free_bindings([], GroundList, FreeList, []) :- as_vars(GroundList, FreeList).
-free_bindings([TermHead|TermTail], GroundList, _, [FreeHead|ResListTail]) :-
+% idea behind free_bindings:
+% destructure input term iteratively, ultimately reaching every ground atom that needs to be replaced by a free variable
+% based on current term structure three processing methods:
+%   variables: no replacement required --> appending to result list as left-most element 
+%   ground atoms: replacement required -->
+%       appending atom to GroundList so that it gets replaced in the base case,
+%       retrieving corresponding free variable from FreeList and append it as left-most element to result list
+%   predicates: no replacement required --> 
+%       destructuring with =.. and calling recursion on its arguments
+%       reassembling predicate after all inner arguments have been processed
+%       adding predicate (now containing only free variables) as left-most element to result list
+%
+% obstacles: Same bindings must be replaced with same variables --> first collecting all bindings in list and only then replacing them   
+
+% base case: replacing all ground atoms in Ground with free variables
+free_bindings([], GroundList, FreeList, []) :- 
+    % list_to_set to obtain same variable name for same binding
+    list_to_set(GroundList, GroundSet),
+    % for each ground atom in GroundSet get one fresh free variable
+    as_vars(GroundSet, FreeSet),
+    unifiable(FreeSet, GroundSet, UnifBag),
+    % change ground atoms to variables according to pairing in UnifBag
+    ground_to_var(GroundList, UnifBag, FreeList).
+% handling variables
+free_bindings([TermHead|TermTail], GroundList, FreeList, [TermHead|ResListTail]) :-
     % TermHead is a variable
     var(TermHead),
-    % appending TermHead to GroundList as well to avoid possible variable naming clashes
-    free_bindings(TermTail, [TermHead|GroundList], [FreeHead|_], ResListTail).
-free_bindings([TermHead|TermTail], GroundTail, _, [FreeHead|ResTail]) :-
+    free_bindings(TermTail, GroundList, FreeList, ResListTail).
+% handling ground atoms
+free_bindings([TermHead|TermTail], GroundTail, FreeTail, [FreeHead|ResTail]) :-
     % TermHead no variable (otherwise instantiation errors in =..)
     nonvar(TermHead),
     TermHead =.. [Functor|TList],
     % TermHead is atomic and ground
     TList = [],
-    %nonvar(Functor),
-    free_bindings(TermTail, [Functor|GroundTail], [FreeHead|_], ResTail).
-free_bindings([TermHead|TermTail], GroundList, FreeList, [Predicate]) :-
+    free_bindings(TermTail, [Functor|GroundTail], [FreeHead|FreeTail], ResTail).
+% handling non-ground predicates
+free_bindings([TermHead|_], GroundList, FreeList, [Predicate]) :-
     % TermHead no variable (otherwise instantiation errors in =..)
     nonvar(TermHead),
     TermHead =.. [Functor|TList],
@@ -84,16 +102,15 @@ free_bindings([TermHead|TermTail], GroundList, FreeList, [Predicate]) :-
     free_bindings(TList, GroundList, FreeList, ResListTail),
     Predicate =.. [Functor|ResListTail].
 
+
 p(G, RoundedResult) :-
     %as_vars(G, GFree),
-    free_bindings([G], [], _, GFree),
+    free_bindings([G], [], _, [GFree]),
     z(G, Numerator, _),
     z(GFree, Denominator, _),
     Result is Numerator / Denominator,
     round_third(Result, RoundedResult).
 
-% --- WIP End ---
-
 % propagates bindings of CurrentGoal to RemainingGoal
 % the List in the form [X=a, Y=b, ...]
 % https://stackoverflow.com/a/64722773
@@ -212,6 +229,9 @@ z(G, Weight, Depth) :-
 0.2 :: qq(a).
 0.1 :: qq(b).
 
+5/10 :: qq(a).
+3/10 :: qq(b).
+
 0.2 :: f(b).
 0.6 :: f(X).
 0.2 :: f(X) :- fail.

commit f346990691118404fa5da6e5c57a666eee014260
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Wed Sep 20 17:21:47 2023 +0200

    fixing issues with marginal and sc inference overlap (when binding variable Depth to value), wip: freeing bindings in input goal for p, still missing: same variable names for same bindings

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index d3805de..db61ef4 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -56,20 +56,37 @@ p(G, ArgList, RoundedResult) :-
 % https://stackoverflow.com/questions/37260614/prolog-replacing-subterms/53145013#53145013
 % https://stackoverflow.com/questions/22812691/prolog-replace-each-instance-of-a-constant-in-a-list-with-a-variable
 
-as_vars_helper([], [], _).
-as_vars_helper([I|Is], [V|Vs], Map) :-
-    once(member(I/V, Map)),
-    as_vars_helper(Is, Vs, Map).
-
-as_vars(T, TV) :-
-    T =.. [Functor|TList],
-    % TODO: need to remove the functor first (or use t)
-    as_vars_helper(TList, TVList, _),
-    TV =.. [Functor|TVList].
+as_vars([], []).
+as_vars([_|GroundTail], [_|VarsTail]) :-
+    as_vars(GroundTail, VarsTail).
+
+% replacing all ground atoms in Ground with free variables
+free_bindings([], GroundList, FreeList, []) :- as_vars(GroundList, FreeList).
+free_bindings([TermHead|TermTail], GroundList, _, [FreeHead|ResListTail]) :-
+    % TermHead is a variable
+    var(TermHead),
+    % appending TermHead to GroundList as well to avoid possible variable naming clashes
+    free_bindings(TermTail, [TermHead|GroundList], [FreeHead|_], ResListTail).
+free_bindings([TermHead|TermTail], GroundTail, _, [FreeHead|ResTail]) :-
+    % TermHead no variable (otherwise instantiation errors in =..)
+    nonvar(TermHead),
+    TermHead =.. [Functor|TList],
+    % TermHead is atomic and ground
+    TList = [],
+    %nonvar(Functor),
+    free_bindings(TermTail, [Functor|GroundTail], [FreeHead|_], ResTail).
+free_bindings([TermHead|TermTail], GroundList, FreeList, [Predicate]) :-
+    % TermHead no variable (otherwise instantiation errors in =..)
+    nonvar(TermHead),
+    TermHead =.. [Functor|TList],
+    % mutual exclusivity of clauses preventing false results via backtracking (e.g. for free_bindings([f(a)], [], _, Free))
+    TList \= [],
+    free_bindings(TList, GroundList, FreeList, ResListTail),
+    Predicate =.. [Functor|ResListTail].
 
 p(G, RoundedResult) :-
     %as_vars(G, GFree),
-    replace(G, b, X, GFree),
+    free_bindings([G], [], _, GFree),
     z(G, Numerator, _),
     z(GFree, Denominator, _),
     Result is Numerator / Denominator,
@@ -91,7 +108,7 @@ round_third(Float, RoundedFloat) :-
     RoundedFloat is RoundedScaled/1000. 
 
 % Akk is the Weight, can be a float or a List. zero depth base case for concatenation: need empty lists. Depth gets increased in each z recursion, not per unifSet_rec recursion
-unifSet_rec(_, _, [], [], 0) :- !.
+unifSet_rec(_, _, [], [], Depth) :- nonvar(Depth), Depth = 0, !.
 unifSet_rec(_, _, [], 0, _) :- !. % base case cut: prevents further backtracking and final output "false"
 unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk, Depth) :-
     % unifSet_rec recursion requires all subgoals to be as unbound as possible
@@ -105,11 +122,12 @@ unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk, Depth) :-
     % UnifBag then has the instantiation of variables for the current C (UnifClause)
     % e.g. [X=Y, Y=b]
     unifiable(CurrentGoal, ClauseHead, UnifBag),
-    unify_helper(RemainingGoal, UnifBag), % how should unify_helper behave if variables in UnifBag have more unification options?
-    DepthNew is Depth+1,
+    unify_helper(RemainingGoal, UnifBag), % TODO: how should unify_helper behave if variables in UnifBag have more unification options?
+    % incrementing Depth value for marginal inference when reaching new level for z recursion
+    ( nonvar(Depth) -> DepthNew is Depth+1; DepthNew = Depth),
     z((ClauseBody, RemainingGoal), Weight, DepthNew),
     unifSet_rec(CurrentGoalFree, RemainingGoalFree, UnifSetTailFree, Akknew, Depth),
-    ( Depth = 0
+    ( nonvar(Depth), Depth = 0
         % marginal inf toplevel
         ->  BindingProb is ClauseProb*Weight,
             round_third(BindingProb, BindingProbRound), % rounding probability occurring in output

commit 3062176df4df1dae36e8b1fd72bc0b1f258d0825
Author: mxs <mxs@dismail.de>
Date:   Wed Sep 20 13:06:42 2023 +0200

    progress on p/2 prerequisites and move muggleton sampling to separate file

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 4e47fd2..d3805de 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -62,21 +62,10 @@ as_vars_helper([I|Is], [V|Vs], Map) :-
     as_vars_helper(Is, Vs, Map).
 
 as_vars(T, TV) :-
-    T =.. TList,
+    T =.. [Functor|TList],
+    % TODO: need to remove the functor first (or use t)
     as_vars_helper(TList, TVList, _),
-    TV =.. TVList.
-
-replace(Term,Term,With,With) :-
-    !.
-replace(Term,Find,Replacement,Result) :-
-    Term =.. [Functor|Args],
-    replace_args(Args,Find,Replacement,ReplacedArgs),
-    Result =.. [Functor|ReplacedArgs].
-
-replace_args([],_,_,[]).
-replace_args([Arg|Rest],Find,Replacement,[ReplacedArg|ReplacedRest]) :-
-    replace(Arg,Find,Replacement,ReplacedArg),
-    replace_args(Rest,Find,Replacement,ReplacedRest).
+    TV =.. [Functor|TVList].
 
 p(G, RoundedResult) :-
     %as_vars(G, GFree),
@@ -193,38 +182,6 @@ z(G, Weight, Depth) :-
     findall([Prob, G, Body], clause((Prob :: G), Body), UnifSet),
     unifSet_rec(G, true, UnifSet, Weight, Depth).
 
-
-% compound body
-sample((G1, G2)) :-
-    !,
-    sample(G1),
-    sample(G2).
-
-% Should this case really be a subclause of sample or does it rather belong to the (toplevel) metainterpreter
-sample(G) :-
-    \+clause((Prob :: G), _),
-    !,
-    G.
-
-sample(Head) :-
-    findall([Prob, Head, Body], clause((Prob :: Head), Body), Bag),
-    random_clause(Head, Body, Bag),
-    !,
-    sample(Body).
-
-% probabilistic clause selector
-random_clause(Head, Body, Bag) :-
-    Rand is random_float,
-    choose(Bag, Head, Body, 0, Rand, Sum).
-choose([], _, _, _, _, 0).
-choose([[Prob, Head, Body]|Tail], Head1, Body1, Akk, Rand, Rest) :-
-    Akknew is Akk + Prob,
-    choose(Tail, Head1, Body1, Akknew, Rand, Rest1),
-    Rest is Rest1 + Prob,
-    ((var(Body1),
-        Prob1 is Akk/(Akk+Rest), Rand >= Prob1, Head1 = Head, Body1 = Body);
-    true).
-
 % TESTS
 % want: z((q(X), p(X)), W) === 0.46
 0.6 :: p(a).
diff --git a/src/sampling.pl b/src/sampling.pl
new file mode 100644
index 0000000..cfe0fc5
--- /dev/null
+++ b/src/sampling.pl
@@ -0,0 +1,30 @@
+% compound body
+sample((G1, G2)) :-
+    !,
+    sample(G1),
+    sample(G2).
+
+% Should this case really be a subclause of sample or does it rather belong to the (toplevel) metainterpreter
+sample(G) :-
+    \+clause((Prob :: G), _),
+    !,
+    G.
+
+sample(Head) :-
+    findall([Prob, Head, Body], clause((Prob :: Head), Body), Bag),
+    random_clause(Head, Body, Bag),
+    !,
+    sample(Body).
+
+% probabilistic clause selector
+random_clause(Head, Body, Bag) :-
+    Rand is random_float,
+    choose(Bag, Head, Body, 0, Rand, Sum).
+choose([], _, _, _, _, 0).
+choose([[Prob, Head, Body]|Tail], Head1, Body1, Akk, Rand, Rest) :-
+    Akknew is Akk + Prob,
+    choose(Tail, Head1, Body1, Akknew, Rand, Rest1),
+    Rest is Rest1 + Prob,
+    ((var(Body1),
+        Prob1 is Akk/(Akk+Rest), Rand >= Prob1, Head1 = Head, Body1 = Body);
+    true).

commit 05da5406b5f0780e67e2ea2d23bc4787564e2b22
Author: mxs <mxs@dismail.de>
Date:   Wed Sep 20 12:42:27 2023 +0200

    comments + todo

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 090468e..4e47fd2 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -6,7 +6,7 @@
 %   normalized SLP (all clauses forming a predicate add up to 1)
 %   pure SLP (no non-prob. clauses)
 
-replace_left(_, [], []).
+% when the VarList is exhausted, set the result to the singe remaining entry in the weight, that entry is the probability
 replace_left([], Remains, Remains).
 replace_left([NewL|TailNewL], [_=R|Tail], [NewL=R|Res]) :-
     var(NewL),
@@ -16,12 +16,23 @@ replace_left([NewL|TailNewL], [_=R|Tail], Res) :-
     nonvar(NewL),
     replace_left(TailNewL, [_=R|Tail], Res).                
     
-% works for inference_marginal(q(X), Prob) but not inference_marginal((s(X,Y),r(Y,Z)), Prob)
-% in the latter case Y is not part of the list in Weight but rather detemined by backtracking and output seperate (at least, if copy_term removed)
-inference_marginal(Goal, BindingProbList) :-  
-    term_variables(Goal, VarList), % preserving variable names for pretty output; TODO: may order of vars in list differ from the order in the output list?
+% example call: inference_marginal((s(X,Y),r(Y,Z)), Prob)
+% in the general case, one Variable (TODO: which?) is not part of the list in Weight but rather detemined by backtracking
+inference_marginal(Goal, ProbList) :-
+    % example goal: (s(X,Y), r(Y,Z))
+    % ---> VarList === [X,Y,Z]
+    % after z call: VarList === [X,b,Z]
+    % because of that:
+    % preserving variable names for pretty output
+    % TODO: may order of vars in list differ from the order in the output list?
+    term_variables(Goal, VarList),
     z(Goal, Weight, 0), 
-    maplist(replace_left(VarList), Weight, BindingProbList).
+    % for the example goal of (s(X,Y), r(Y,Z)), we currently have
+    % Y=b,
+    % Weight = [[b=b, _=X, 0.14], [c=c, _=a, 0], [b=b, _=b, 0.04]]
+    % invariant: forall w in Weight. len(VarList - ground terms) === len(w - last element)
+    % replace_left then takes the variables from VarList and replaces the left hand '=' sides with them in order (for each w in Weight [is a list])
+    maplist(replace_left(VarList), Weight, ProbList).
 
 
 % assumptions:
@@ -90,25 +101,33 @@ round_third(Float, RoundedFloat) :-
     RoundedScaled is round(Float*1000),
     RoundedFloat is RoundedScaled/1000. 
 
+% Akk is the Weight, can be a float or a List. zero depth base case for concatenation: need empty lists. Depth gets increased in each z recursion, not per unifSet_rec recursion
+unifSet_rec(_, _, [], [], 0) :- !.
 unifSet_rec(_, _, [], 0, _) :- !. % base case cut: prevents further backtracking and final output "false"
 unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk, Depth) :-
     % unifSet_rec recursion requires all subgoals to be as unbound as possible
     % free variable relations must be preserved, e.g. p(X), q(X) must become p(Y), q(Y)
+    % -> copy everything but the current C (UnifClause)
     copy_term((CurrentGoal,RemainingGoal, UnifSetTail), (CurrentGoalFree,RemainingGoalFree, UnifSetTailFree)),
 
     nth0(0, UnifClause, ClauseProb),
     nth0(1, UnifClause, ClauseHead),
     nth0(2, UnifClause, ClauseBody),
-    unifiable(ClauseHead, CurrentGoal, UnifBag),
+    % UnifBag then has the instantiation of variables for the current C (UnifClause)
+    % e.g. [X=Y, Y=b]
+    unifiable(CurrentGoal, ClauseHead, UnifBag),
     unify_helper(RemainingGoal, UnifBag), % how should unify_helper behave if variables in UnifBag have more unification options?
     DepthNew is Depth+1,
     z((ClauseBody, RemainingGoal), Weight, DepthNew),
     unifSet_rec(CurrentGoalFree, RemainingGoalFree, UnifSetTailFree, Akknew, Depth),
     ( Depth = 0
+        % marginal inf toplevel
         ->  BindingProb is ClauseProb*Weight,
             round_third(BindingProb, BindingProbRound), % rounding probability occurring in output
+            % [X=Y, Y=b] <> [0.3] === [X=Y, Y=b, 0.3]
             append(UnifBag, [BindingProbRound], AkkTemp),
-            ( \+ integer(Akknew) -> append([AkkTemp], Akknew, Akk); Akk = [AkkTemp] ) % for all but the last element in unif set Akknew will be a list
+            append([AkkTemp], Akknew, Akk) % for all but the last element in unif set Akknew will be a list
+        % SC inf / marginal recursive
         ;   Akk is ClauseProb*Weight + Akknew).
 
 substitSet_rec(_, _, [], 0, _) :- !. % base case cut: prevents further backtracking and final output "false"
@@ -118,10 +137,12 @@ substitSet_rec(CurrentGoal, RemainingGoal, [Substitutions|PairedVarBindingsTail]
     % free variable relations must be preserved, e.g. p(X), q(X) must become p(Y), q(Y)
     copy_term((CurrentGoal,RemainingGoal, PairedVarBindingsTail), (CurrentGoalFree,RemainingGoalFree, PairedVarBindingsTailFree)),
 
+    % here, the third argument of substitSet_rec are suitable substitutions, as opposed to clauses in unifSet_rec
     unify_helper(CurrentGoal, Substitutions),
     unify_helper(RemainingGoal, Substitutions),
     z(CurrentGoal, Weight1, Depth),
     z(RemainingGoal, Weight2, Depth),
+    % sum over all possible splitting substitutions
     substitSet_rec(CurrentGoalFree, RemainingGoalFree, PairedVarBindingsTailFree, Akknew, Depth),
     Akk is Weight1*Weight2 + Akknew.
 
@@ -149,9 +170,15 @@ z((G1, G2), Weight, Depth) :-
             z(G2, Weight2, Depth),
             Weight is Weight1*Weight2
         % shared variables --> computation of splitting substitution set
-        ;   % only ground terms make goals disjunct
+        ;   % only ground terms make goals disjunct (e.g. we don't want Y=Y)
+            % collect all possible values of SharedVars in matching clause heads
+            % example: (G1, G2) === (s(X,Y), r(Y,Z))
+            % ---> SharedVars = [Y]
+            % ---> SubstitList = [[b],[c]]; in each entry list we have the bindings for all shared variables
             findall(SharedVars, (clause((_ :: G1), _), ground(SharedVars)), SubstitList),
+            % SubstitSet is Theta, the set of splitting substitutions. in the (s(X,Y), r(Y,Z)) case, a substitution of Y= b or Y= c makes the Variables in G1, G2 disjoint
             list_to_set(SubstitList, SubstitSet),
+            % put all possibilities for binding the shared variables into PairedVarBindings
             maplist(unifiable(SharedVars), SubstitSet, PairedVarBindings),
             substitSet_rec(G1, G2, PairedVarBindings, Weight, Depth)        
         )
@@ -222,5 +249,3 @@ choose([[Prob, Head, Body]|Tail], Head1, Body1, Akk, Rand, Rest) :-
 0.2 :: s(b, b).
 0.2 :: r(b, Z) :- p(Z).
 0.8 :: r(a, b).
-
-% current state: inference_marginal((s(X,Y), r(Y,Z)), Prob) results in Y=b, Prob = [b=b, _=X, 0.14, c=c, _=a, 0, b=b, _=b, 0.04] ; false.
diff --git a/src/demo_doc.pl b/src/demo_doc.pl
index de45d8f..a71b61f 100644
--- a/src/demo_doc.pl
+++ b/src/demo_doc.pl
@@ -1,12 +1,12 @@
 % TODO
-% - möglicherweise SC_inf unifset anpassen -> email
-% - marginal aus SC inference
 % - p/2 implementation
 % - special sampling mit SC inference
 % - constrained sampling
 % - cuts
-% - code organisation
+% - code organisation / refactor marginal-SC
 % - unconstrained sampling (ohne inference call)
+% - improving output of marginal and remove type error (Weight can be float in SC case or List of Lists in marginal case)
+% - splitting for marginal
 
 0.6 :: q(X).
 0.2 :: q(a).

commit 5939b8813d5e0b4230284f1cbfddcbf50bf55fd5
Merge: ec605ab 5434d1f
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Wed Sep 20 09:00:46 2023 +0200

    Merge branch 'master' of gitlab.lrz.de:000000000135D322/plp

commit ec605ab25727dd80e5e3d407ebe22713421b8ed7
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Wed Sep 20 08:59:31 2023 +0200

    prettier output for marginal inference

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 0b1545b..ef492a5 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -9,14 +9,18 @@
 replace_left(_, [], []).
 replace_left([], Remains, Remains).
 replace_left([NewL|TailNewL], [_=R|Tail], [NewL=R|Res]) :-
-    replace_left(TailNewL, Tail, Res).        
+    var(NewL),
+    replace_left(TailNewL, Tail, Res).
+% ignoring already globally bound variables s.t. lenght of binding list [_=R|Tail] equals list of new lefts [NewL|TailNewL]
+replace_left([NewL|TailNewL], [_=R|Tail], Res) :-
+    nonvar(NewL),
+    replace_left(TailNewL, [_=R|Tail], Res).                
     
 % works for inference_marginal(q(X), Prob) but not inference_marginal((s(X,Y),r(Y,Z)), Prob)
 % in the latter case Y is not part of the list in Weight but rather detemined by backtracking and output seperate (at least, if copy_term removed)
 inference_marginal(Goal, BindingProbList) :-  
-    copy_term(Goal, GoalFree), % preserving original variable names for output
-    z(GoalFree, Weight, 0),
-    term_variables(Goal, VarList), % TODO: may order of vars in list differ from the order in the output list?
+    term_variables(Goal, VarList), % preserving variable names for pretty output; TODO: may order of vars in list differ from the order in the output list?
+    z(Goal, Weight, 0), 
     maplist(replace_left(VarList), Weight, BindingProbList).
 
 

commit 5434d1f1186e32fb8d4bc6b5534fdc0236f52be9
Author: mxs <mxs@dismail.de>
Date:   Tue Sep 19 17:42:43 2023 +0200

    refactor
    
    + edit todo

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 0b1545b..1612729 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -73,12 +73,6 @@ p(G, RoundedResult) :-
 
 % --- WIP End ---
 
-% reimplementation of maplist for singleton list [Singleton] applied to arbitrarily long list [Elem|Tail]
-map_singleton(_, _, [], []) :- !.
-map_singleton(Goal, [Singleton], [Elem|Tail], [ResElem|ResTail]) :-
-    call(Goal, Singleton, Elem, ResElem),
-    map_singleton(Goal, [Singleton], Tail, ResTail).
-
 % propagates bindings of CurrentGoal to RemainingGoal
 % the List in the form [X=a, Y=b, ...]
 % https://stackoverflow.com/a/64722773
@@ -138,7 +132,6 @@ z((true, G), Weight, Depth) :- z(G, Weight, Depth), !.
 % compound head
 z((G1, G2), Weight, Depth) :-
     G1 \= true, % mutual exclusivity of goals
-
     % marginal inference --> standard not optimised z computation (with nonvar Depth)
     ( nonvar(Depth) 
     ->  findall([Prob, G1, Body], clause((Prob :: G1), Body), UnifSet),
@@ -155,8 +148,7 @@ z((G1, G2), Weight, Depth) :-
         ;   % only ground terms make goals disjunct
             findall(SharedVars, (clause((_ :: G1), _), ground(SharedVars)), SubstitList),
             list_to_set(SubstitList, SubstitSet),
-
-            map_singleton(unifiable, [SharedVars], SubstitSet, PairedVarBindings),
+            maplist(unifiable(SharedVars), SubstitSet, PairedVarBindings),
             substitSet_rec(G1, G2, PairedVarBindings, Weight, Depth)        
         )
     ).
diff --git a/src/demo_doc.pl b/src/demo_doc.pl
index aa9b942..de45d8f 100644
--- a/src/demo_doc.pl
+++ b/src/demo_doc.pl
@@ -4,6 +4,8 @@
 % - p/2 implementation
 % - special sampling mit SC inference
 % - constrained sampling
+% - cuts
+% - code organisation
 % - unconstrained sampling (ohne inference call)
 
 0.6 :: q(X).

commit 73275f2519e55c37825a161f5dc8996eddad5e25
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Tue Sep 19 22:59:21 2023 +0200

    var argument Depth in p; attempt: pretty output for marginal_inference

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index de954cc..0b1545b 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -6,15 +6,25 @@
 %   normalized SLP (all clauses forming a predicate add up to 1)
 %   pure SLP (no non-prob. clauses)
 
+replace_left(_, [], []).
+replace_left([], Remains, Remains).
+replace_left([NewL|TailNewL], [_=R|Tail], [NewL=R|Res]) :-
+    replace_left(TailNewL, Tail, Res).        
+    
+% works for inference_marginal(q(X), Prob) but not inference_marginal((s(X,Y),r(Y,Z)), Prob)
+% in the latter case Y is not part of the list in Weight but rather detemined by backtracking and output seperate (at least, if copy_term removed)
+inference_marginal(Goal, BindingProbList) :-  
+    copy_term(Goal, GoalFree), % preserving original variable names for output
+    z(GoalFree, Weight, 0),
+    term_variables(Goal, VarList), % TODO: may order of vars in list differ from the order in the output list?
+    maplist(replace_left(VarList), Weight, BindingProbList).
+
+
 % assumptions:
 %   G is the goal with only free variables
 %   G is non-compound; TODO: assert user input as clause and retract later
 %   ArgList contains the instantiated parameters for G
 
-inference_marginal(Goal, BindingProbList) :- z(Goal, BindingProbList, 0).
-
-
-
 % want p(f(b), P)
 % -> p(f(X), [X=b], P).
 p(G, ArgList, RoundedResult) :-
@@ -56,8 +66,8 @@ replace_args([Arg|Rest],Find,Replacement,[ReplacedArg|ReplacedRest]) :-
 p(G, RoundedResult) :-
     %as_vars(G, GFree),
     replace(G, b, X, GFree),
-    z(G, Numerator, 1),
-    z(GFree, Denominator, 1),
+    z(G, Numerator, _),
+    z(GFree, Denominator, _),
     Result is Numerator / Denominator,
     round_third(Result, RoundedResult).
 
@@ -100,7 +110,7 @@ unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk, Depth) :-
         ->  BindingProb is ClauseProb*Weight,
             round_third(BindingProb, BindingProbRound), % rounding probability occurring in output
             append(UnifBag, [BindingProbRound], AkkTemp),
-            ( \+ integer(Akknew) -> append(AkkTemp, Akknew, Akk); Akk = AkkTemp ) % for all but the last element in unif set Akknew will be a list
+            ( \+ integer(Akknew) -> append([AkkTemp], Akknew, Akk); Akk = [AkkTemp] ) % for all but the last element in unif set Akknew will be a list
         ;   Akk is ClauseProb*Weight + Akknew).
 
 substitSet_rec(_, _, [], 0, _) :- !. % base case cut: prevents further backtracking and final output "false"

commit 9fd3021a41d46de95dfd4aebdfd6e9926cc4defe
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Tue Sep 19 21:47:24 2023 +0200

    marginal inference derived from success contraint inference; unpleasant looking result

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 82221e8..de954cc 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -11,13 +11,17 @@
 %   G is non-compound; TODO: assert user input as clause and retract later
 %   ArgList contains the instantiated parameters for G
 
+inference_marginal(Goal, BindingProbList) :- z(Goal, BindingProbList, 0).
+
+
+
 % want p(f(b), P)
 % -> p(f(X), [X=b], P).
 p(G, ArgList, RoundedResult) :-
     copy_term(G, GFree),
     unify_helper(G, ArgList),
-    z(G, Numerator),
-    z(GFree, Denominator),
+    z(G, Numerator, _),
+    z(GFree, Denominator, _),
     Result is Numerator / Denominator,
     round_third(Result, RoundedResult).
 
@@ -52,8 +56,8 @@ replace_args([Arg|Rest],Find,Replacement,[ReplacedArg|ReplacedRest]) :-
 p(G, RoundedResult) :-
     %as_vars(G, GFree),
     replace(G, b, X, GFree),
-    z(G, Numerator),
-    z(GFree, Denominator),
+    z(G, Numerator, 1),
+    z(GFree, Denominator, 1),
     Result is Numerator / Denominator,
     round_third(Result, RoundedResult).
 
@@ -78,8 +82,8 @@ round_third(Float, RoundedFloat) :-
     RoundedScaled is round(Float*1000),
     RoundedFloat is RoundedScaled/1000. 
 
-unifSet_rec(_, _, [], 0) :- !. % base case cut: prevents further backtracking and final output "false"
-unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk) :-
+unifSet_rec(_, _, [], 0, _) :- !. % base case cut: prevents further backtracking and final output "false"
+unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk, Depth) :-
     % unifSet_rec recursion requires all subgoals to be as unbound as possible
     % free variable relations must be preserved, e.g. p(X), q(X) must become p(Y), q(Y)
     copy_term((CurrentGoal,RemainingGoal, UnifSetTail), (CurrentGoalFree,RemainingGoalFree, UnifSetTailFree)),
@@ -89,12 +93,18 @@ unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk) :-
     nth0(2, UnifClause, ClauseBody),
     unifiable(ClauseHead, CurrentGoal, UnifBag),
     unify_helper(RemainingGoal, UnifBag), % how should unify_helper behave if variables in UnifBag have more unification options?
-    z((ClauseBody, RemainingGoal), Weight),
-    unifSet_rec(CurrentGoalFree, RemainingGoalFree, UnifSetTailFree, Akknew),
-    Akk is ClauseProb*Weight + Akknew.
-
-substitSet_rec(_, _, [], 0) :- !. % base case cut: prevents further backtracking and final output "false"
-substitSet_rec(CurrentGoal, RemainingGoal, [Substitutions|PairedVarBindingsTail], Akk) :-
+    DepthNew is Depth+1,
+    z((ClauseBody, RemainingGoal), Weight, DepthNew),
+    unifSet_rec(CurrentGoalFree, RemainingGoalFree, UnifSetTailFree, Akknew, Depth),
+    ( Depth = 0
+        ->  BindingProb is ClauseProb*Weight,
+            round_third(BindingProb, BindingProbRound), % rounding probability occurring in output
+            append(UnifBag, [BindingProbRound], AkkTemp),
+            ( \+ integer(Akknew) -> append(AkkTemp, Akknew, Akk); Akk = AkkTemp ) % for all but the last element in unif set Akknew will be a list
+        ;   Akk is ClauseProb*Weight + Akknew).
+
+substitSet_rec(_, _, [], 0, _) :- !. % base case cut: prevents further backtracking and final output "false"
+substitSet_rec(CurrentGoal, RemainingGoal, [Substitutions|PairedVarBindingsTail], Akk, Depth) :-
     % substitSet_rec recursion requires all subgoals to be as unbound as possible
     % PairedVarBindings must also remain unbound, e.g. old: [X=a], [X=b] becomes [Y=b] instead of [a=b]
     % free variable relations must be preserved, e.g. p(X), q(X) must become p(Y), q(Y)
@@ -102,46 +112,53 @@ substitSet_rec(CurrentGoal, RemainingGoal, [Substitutions|PairedVarBindingsTail]
 
     unify_helper(CurrentGoal, Substitutions),
     unify_helper(RemainingGoal, Substitutions),
-    z(CurrentGoal, Weight1),
-    z(RemainingGoal, Weight2),
-    substitSet_rec(CurrentGoalFree, RemainingGoalFree, PairedVarBindingsTailFree, Akknew),
+    z(CurrentGoal, Weight1, Depth),
+    z(RemainingGoal, Weight2, Depth),
+    substitSet_rec(CurrentGoalFree, RemainingGoalFree, PairedVarBindingsTailFree, Akknew, Depth),
     Akk is Weight1*Weight2 + Akknew.
 
 % base case
-z(true, 1).
+z(true, 1, _).
 
 % compound base cases; simplifying conjunction
 % base case cuts: prevent further backtracking and final output "false"
-z((G, true), Weight) :- z(G, Weight), !. % fires for G as body of a non-compound head
-z((true, G), Weight) :- z(G, Weight), !.
+z((G, true), Weight, Depth) :- z(G, Weight, Depth), !. % fires for G as body of a non-compound head
+z((true, G), Weight, Depth) :- z(G, Weight, Depth), !.
 
 % compound head
-z((G1, G2), Weight) :-
+z((G1, G2), Weight, Depth) :-
     G1 \= true, % mutual exclusivity of goals
 
-    % shared variable test
-    sub_term_shared_variables(G1, (G1, G2), SharedVars),
-    ( SharedVars = [] 
-    % no shared variables --> decomposition
-    ->  z(G1, Weight1),
-        z(G2, Weight2),
-        Weight is Weight1*Weight2
-    % shared variables --> computation of splitting substitution set
-    ;   % only ground terms make goals disjunct
-        findall(SharedVars, (clause((_ :: G1), _), ground(SharedVars)), SubstitList),
-        list_to_set(SubstitList, SubstitSet),
-        map_singleton(unifiable, [SharedVars], SubstitSet, PairedVarBindings),
-        substitSet_rec(G1, G2, PairedVarBindings, Weight)        
+    % marginal inference --> standard not optimised z computation (with nonvar Depth)
+    ( nonvar(Depth) 
+    ->  findall([Prob, G1, Body], clause((Prob :: G1), Body), UnifSet),
+        unifSet_rec(G1, G2, UnifSet, Weight, Depth)
+    % success constraint inference --> optimised z computation (with var Depth)
+    ;   % shared variable test
+        sub_term_shared_variables(G1, (G1, G2), SharedVars),
+        ( SharedVars = [] 
+        % no shared variables --> decomposition
+        ->  z(G1, Weight1, Depth),
+            z(G2, Weight2, Depth),
+            Weight is Weight1*Weight2
+        % shared variables --> computation of splitting substitution set
+        ;   % only ground terms make goals disjunct
+            findall(SharedVars, (clause((_ :: G1), _), ground(SharedVars)), SubstitList),
+            list_to_set(SubstitList, SubstitSet),
+
+            map_singleton(unifiable, [SharedVars], SubstitSet, PairedVarBindings),
+            substitSet_rec(G1, G2, PairedVarBindings, Weight, Depth)        
+        )
     ).
 
 % non-compound head
-z(G, Weight) :-
+z(G, Weight, Depth) :-
     % mutual exclusivity of goals
     G \= (_, _),
     G \= true,
 
     findall([Prob, G, Body], clause((Prob :: G), Body), UnifSet),
-    unifSet_rec(G, true, UnifSet, Weight).
+    unifSet_rec(G, true, UnifSet, Weight, Depth).
 
 
 % compound body
@@ -199,3 +216,5 @@ choose([[Prob, Head, Body]|Tail], Head1, Body1, Akk, Rand, Rest) :-
 0.2 :: s(b, b).
 0.2 :: r(b, Z) :- p(Z).
 0.8 :: r(a, b).
+
+% current state: inference_marginal((s(X,Y), r(Y,Z)), Prob) results in Y=b, Prob = [b=b, _=X, 0.14, c=c, _=a, 0, b=b, _=b, 0.04] ; false.

commit 2e4e41e6a9d71603df1e8dc4e9be6799913d7707
Author: mxs <mxs@dismail.de>
Date:   Tue Sep 19 16:04:02 2023 +0200

    fix p/3, wip p/2, add TODO list

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index bb9981b..82221e8 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -10,21 +10,61 @@
 %   G is the goal with only free variables
 %   G is non-compound; TODO: assert user input as clause and retract later
 %   ArgList contains the instantiated parameters for G
+
+% want p(f(b), P)
+% -> p(f(X), [X=b], P).
 p(G, ArgList, RoundedResult) :-
-    functor(G, Functor, Arity),
-    GInstantiated =.. [Functor|ArgList],
-    z(GInstantiated, Numerator),
-    z(G, Denominator),
+    copy_term(G, GFree),
+    unify_helper(G, ArgList),
+    z(G, Numerator),
+    z(GFree, Denominator),
+    Result is Numerator / Denominator,
+    round_third(Result, RoundedResult).
+
+% ---WIP---
+
+% https://stackoverflow.com/questions/12638347/replace-atom-with-variable
+% https://stackoverflow.com/questions/37260614/prolog-replacing-subterms/53145013#53145013
+% https://stackoverflow.com/questions/22812691/prolog-replace-each-instance-of-a-constant-in-a-list-with-a-variable
+
+as_vars_helper([], [], _).
+as_vars_helper([I|Is], [V|Vs], Map) :-
+    once(member(I/V, Map)),
+    as_vars_helper(Is, Vs, Map).
+
+as_vars(T, TV) :-
+    T =.. TList,
+    as_vars_helper(TList, TVList, _),
+    TV =.. TVList.
+
+replace(Term,Term,With,With) :-
+    !.
+replace(Term,Find,Replacement,Result) :-
+    Term =.. [Functor|Args],
+    replace_args(Args,Find,Replacement,ReplacedArgs),
+    Result =.. [Functor|ReplacedArgs].
+
+replace_args([],_,_,[]).
+replace_args([Arg|Rest],Find,Replacement,[ReplacedArg|ReplacedRest]) :-
+    replace(Arg,Find,Replacement,ReplacedArg),
+    replace_args(Rest,Find,Replacement,ReplacedRest).
+
+p(G, RoundedResult) :-
+    %as_vars(G, GFree),
+    replace(G, b, X, GFree),
+    z(G, Numerator),
+    z(GFree, Denominator),
     Result is Numerator / Denominator,
     round_third(Result, RoundedResult).
 
+% --- WIP End ---
+
 % reimplementation of maplist for singleton list [Singleton] applied to arbitrarily long list [Elem|Tail]
 map_singleton(_, _, [], []) :- !.
 map_singleton(Goal, [Singleton], [Elem|Tail], [ResElem|ResTail]) :-
     call(Goal, Singleton, Elem, ResElem),
     map_singleton(Goal, [Singleton], Tail, ResTail).
 
-
 % propagates bindings of CurrentGoal to RemainingGoal
 % the List in the form [X=a, Y=b, ...]
 % https://stackoverflow.com/a/64722773
@@ -143,6 +183,10 @@ choose([[Prob, Head, Body]|Tail], Head1, Body1, Akk, Rand, Rest) :-
 0.6 :: q(b).
 0.1 :: q(c).
 
+0.6 :: qq(X).
+0.2 :: qq(a).
+0.1 :: qq(b).
+
 0.2 :: f(b).
 0.6 :: f(X).
 0.2 :: f(X) :- fail.
diff --git a/src/demo_doc.pl b/src/demo_doc.pl
index a7df2be..aa9b942 100644
--- a/src/demo_doc.pl
+++ b/src/demo_doc.pl
@@ -1,3 +1,11 @@
+% TODO
+% - möglicherweise SC_inf unifset anpassen -> email
+% - marginal aus SC inference
+% - p/2 implementation
+% - special sampling mit SC inference
+% - constrained sampling
+% - unconstrained sampling (ohne inference call)
+
 0.6 :: q(X).
 0.2 :: q(a).
 % we have implicit failure, so, additionally:
@@ -26,6 +34,8 @@
 % inference_marginal(q(X), P).
 % ---> X = Omega - {a}, P = 0.6.
 % ---> X = a, P = 0.8
+% inference_marginal(q(b), P).
+% ---> X = b, P = 0.6
 % inference_marginal(qq(X), P).
 % ---> X = a, P = 5/10.
 % ---> X = b, P = 3/10.
@@ -41,6 +51,8 @@
 %   the denominator z(q(X), P) gives P = 0.8 because [check this] that is the required normalization weight for the correct final result
 % inference_sc(q(X), P).
 % ---> X = a, P = 1
+% inference_sc(q(b), P).
+% ---> X = b, P = 0.75
 % inference_sc(qq(X), P).
 % ---> X = a, P = 5/8
 % ---> X = b, P = 3/8

commit 4ac43d662c2d5a220037c3e168ed200f923ca5e1
Author: mxs <mxs@dismail.de>
Date:   Tue Sep 19 13:19:45 2023 +0200

    identify current defects

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 1bb4499..bb9981b 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -145,6 +145,10 @@ choose([[Prob, Head, Body]|Tail], Head1, Body1, Akk, Rand, Rest) :-
 
 0.2 :: f(b).
 0.6 :: f(X).
+0.2 :: f(X) :- fail.
+
+0.1 :: st(a, b).
+0.9 :: st(X, b) :- fail.
 
 0.7 :: s(X, b) :- q(X).
 0.1 :: s(a, c).
diff --git a/src/demo_doc.pl b/src/demo_doc.pl
new file mode 100644
index 0000000..a7df2be
--- /dev/null
+++ b/src/demo_doc.pl
@@ -0,0 +1,62 @@
+0.6 :: q(X).
+0.2 :: q(a).
+% we have implicit failure, so, additionally:
+% 0.2 :: q(X) :- fail.
+% each functor's probability labels must sum to 1
+% <1: implicit failure
+% >1: error out
+
+5/10 :: qq(a).
+3/10 :: qq(b).
+
+0.5 :: st2(X) :- stt2(X).
+0.5 :: st2(X) :- sst3(X).
+1/2 :: sst2(X) :- fail.
+1/2 :: sst2(a).
+1/2 :: sst3(b).
+1/2 :: sst3(c).
+
+% --------------------
+
+% inference: marginal
+% forall X. what is P such that q(X) terminates successfully
+% implementation: summation over bindings yields the denominator z in Cussen's p (for ground queries; for non-ground it [check this] corresponds to the denominator)
+% API: inference_marginal(q(X), P).
+% ---> X = <binding>, P = <number>
+% inference_marginal(q(X), P).
+% ---> X = Omega - {a}, P = 0.6.
+% ---> X = a, P = 0.8
+% inference_marginal(qq(X), P).
+% ---> X = a, P = 5/10.
+% ---> X = b, P = 3/10.
+% [inference_marginal(q(a), P).
+% ---> P = 0.8.] <- the case where the query is ground is always determined by the corresponding result in the non-ground case
+
+% --------------------
+
+% inference: success-constrained
+% Given q(X) terminates successfully, what is the probability distribution of X as a random variable
+% this is just the P's for each variable binding.
+% implementation: Cussen's p
+%   the denominator z(q(X), P) gives P = 0.8 because [check this] that is the required normalization weight for the correct final result
+% inference_sc(q(X), P).
+% ---> X = a, P = 1
+% inference_sc(qq(X), P).
+% ---> X = a, P = 5/8
+% ---> X = b, P = 3/8
+
+% --------------------
+
+% sampling: unconstrained
+% sampling_uc(st2(X)).
+% ---> X = a, P = 1/2
+% ---> X = b, P = 1/4
+% ---> X = c, P = 1/4
+
+% --------------------
+
+% sampling: constrained
+% sampling_sc(st2(X)).
+% ---> X = a, P = 1/3
+% ---> X = b, P = 1/3
+% ---> X = c, P = 1/3
diff --git a/src/metainterp.pl b/src/metainterp.pl
index d94b850..9e7b635 100644
--- a/src/metainterp.pl
+++ b/src/metainterp.pl
@@ -159,6 +159,22 @@ dice_reward([Player,Banker],[Player+D,Banker-D]) :- sample(roll_dice(D)).
 
 0.2 :: f(b).
 0.6 :: f(X).
+0.2 :: f(X) :- fail.
+
+0.1 :: st0(a, b).
+0.9 :: st0(X, b) :- fail.
+
+0.1 :: st(a).
+0.9 :: st(X) :- fail.
+
+0.5 :: st2(X) :- stt2(X).
+0.5 :: st2(X) :- sst3(X).
+1/2 :: sst2(X) :- fail.
+1/2 :: sst2(a).
+1/2 :: sst3(b).
+1/2 :: sst3(c).
+
+
 
 % TODO/extra:
 % sampling(q(X), q(Z)) -> sampling(q(X)), sampling(q(Z)).

commit 5b191e610a7e0980fe902e1277fea980dc98ef8f
Author: mxs <mxs@dismail.de>
Date:   Tue Sep 19 11:47:11 2023 +0200

    remove old test.pl

diff --git a/src/test.pl b/src/test.pl
deleted file mode 100644
index 26d9724..0000000
--- a/src/test.pl
+++ /dev/null
@@ -1,58 +0,0 @@
-suess(Apfel) :- Apfel, rot(Apfel).
-
-elstar.
-boskop.
-goldendelicious.
-goldparmaene.
-
-rot(elstar).
-rot(goldparmaene).
-
-p(a, b).
-p(b, x).
-q(b).
-r(a, a).
-r(c, d).
-
-
-
-u(X, Y, Z) :- p(X, Y), q(X), r(Z, Z).
-
-exists_member([], V2, noSharing).
-exists_member([Head|Tail], V2, R) :-
-    ( member(Head, V2)
-    -> R = sharing
-    ; exists_member(Tail, V2, R) ).
-
-
-var_equal(G, RG13, RG12, RG23, RG2G3) :-
-    numbervars(G, 0, End),
-    (G1, G2, G3) = G,
-    varnumbers(G1, G1Free),
-    term_variables(G1Free, G1Vars),
-    term_variables(G2, G2Vars),
-    term_variables(G3, G3Vars),
-    term_variables((G2,G3), G2G3Vars),
-    exists_member(G1Vars, G3Vars, RG13),
-    exists_member(G1Vars, G2Vars, RG12),
-    exists_member(G2Vars, G3Vars, RG23),
-    exists_member(G1Vars, G2G3Vars, RG2G3).
-
-var_equal(G, G1Shared, G2Shared, G3Shared) :-
-    (G1, G2, G3) = G,
-    sub_term_shared_variables(G1, G, G1Shared),
-    sub_term_shared_variables(G2, G, G2Shared),
-    sub_term_shared_variables(G3, G, G3Shared).
-
-% rough idea: If GxShared is empty, do recursive splitting as before, i.e. z(G1), z(G\G1) and multiply
-% otherwise: work with list of subgoals!
-%   append new (possibly instantiated) body to list (e.g. as head, order not relevant as we only consider conjunctions so far)
-%   find all subgoals in list sharing the same variable and assign same instantiation to them
-%   call z(transformed_goal) where transformed goal comprises the body replacement and instantiation changes
-
-    
-
-
-
-    
-    
\ No newline at end of file

commit 69bbff741a8ff14a72f77d0a51e81314c0f73b0d
Author: mxs <mxs@dismail.de>
Date:   Tue Sep 19 11:38:00 2023 +0200

    nach gespräch

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 96e91d9..1bb4499 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -140,7 +140,11 @@ choose([[Prob, Head, Body]|Tail], Head1, Body1, Akk, Rand, Rest) :-
 0.6 :: p(a).
 0.4 :: p(b).
 0.3 :: q(a).
-0.7 :: q(b).
+0.6 :: q(b).
+0.1 :: q(c).
+
+0.2 :: f(b).
+0.6 :: f(X).
 
 0.7 :: s(X, b) :- q(X).
 0.1 :: s(a, c).
diff --git a/src/metainterp.pl b/src/metainterp.pl
index 7ba6f27..d94b850 100644
--- a/src/metainterp.pl
+++ b/src/metainterp.pl
@@ -142,9 +142,13 @@ stop([Player,Banker],_) :-
     write('Player = '), write(Player1),
     write('Banker = '), write(Banker1).
 pay_entrance([Player,Banker],[Player-4,Banker+4]).
-dice_reward([Player,Banker],[Player+D,Banker-D]) :- roll_dice(D).
+dice_reward([Player,Banker],[Player+D,Banker-D]) :- sample(roll_dice(D)).
 
-1/6::roll_dice(1).
+% ohne sample(roll_...)) / metapredicate:
+% X :- _ :: X, sample(X).
+
+
+% 1/2 roll_dice(X) :- even_zwischen_2_und_6(X).
 1/6::roll_dice(1).
 1/6::roll_dice(2).
 1/6::roll_dice(3).
@@ -152,6 +156,10 @@ dice_reward([Player,Banker],[Player+D,Banker-D]) :- roll_dice(D).
 1/6::roll_dice(5).
 1/6::roll_dice(6).
 
+
+0.2 :: f(b).
+0.6 :: f(X).
+
 % TODO/extra:
 % sampling(q(X), q(Z)) -> sampling(q(X)), sampling(q(Z)).
 % sampling(q(X), p(Z)) -> sampling(q(X)), sampling(p(Z))
diff --git a/task.txt b/task.txt
index 51b50ee..c317dfc 100644
--- a/task.txt
+++ b/task.txt
@@ -16,10 +16,3 @@ max:
                 wir gehen davon aus das alle ereignisse unabhängig aber nicht disjunkt sind.
                 damit berechnet sich die wahscheinlichekit über p1 + p2 - p1*p2 und ist in jeder clause <= 1.
 
-implementation:
-berechnungen können alle in ffi sein (c/c++/rust), core logic in prolog
-    ffi:
-        https://github.com/k3ut0i/swipl-ffi-examples
-        https://www.swi-prolog.org/pldoc/man?section=shlib
-        https://www.swi-prolog.org/pldoc/man?section=foreign-read-list
-        https://www.swi-prolog.org/pldoc/man?section=foreign-unify

commit c0ce46f7e3d03e8628058ac68473a9f457a59413
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Tue Sep 19 11:36:54 2023 +0200

    comments on sampling implementation of old paper

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 44af391..96e91d9 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -110,8 +110,9 @@ sample((G1, G2)) :-
     sample(G1),
     sample(G2).
 
+% Should this case really be a subclause of sample or does it rather belong to the (toplevel) metainterpreter
 sample(G) :-
-    \+clause(G, _),
+    \+clause((Prob :: G), _),
     !,
     G.
 
@@ -131,7 +132,7 @@ choose([[Prob, Head, Body]|Tail], Head1, Body1, Akk, Rand, Rest) :-
     choose(Tail, Head1, Body1, Akknew, Rand, Rest1),
     Rest is Rest1 + Prob,
     ((var(Body1),
-        Prob1 is Akk/(Akk+Rest), Rand >= P1, Head1 = Head, Body1 = Body);
+        Prob1 is Akk/(Akk+Rest), Rand >= Prob1, Head1 = Head, Body1 = Body);
     true).
 
 % TESTS

commit 6c500020aa3d355b4aa4f97bc90c5da116a0d843
Author: mxs <mxs@dismail.de>
Date:   Wed Sep 13 21:14:10 2023 +0200

    wip: clause selector

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 53bdfed..44af391 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -104,6 +104,36 @@ z(G, Weight) :-
     unifSet_rec(G, true, UnifSet, Weight).
 
 
+% compound body
+sample((G1, G2)) :-
+    !,
+    sample(G1),
+    sample(G2).
+
+sample(G) :-
+    \+clause(G, _),
+    !,
+    G.
+
+sample(Head) :-
+    findall([Prob, Head, Body], clause((Prob :: Head), Body), Bag),
+    random_clause(Head, Body, Bag),
+    !,
+    sample(Body).
+
+% probabilistic clause selector
+random_clause(Head, Body, Bag) :-
+    Rand is random_float,
+    choose(Bag, Head, Body, 0, Rand, Sum).
+choose([], _, _, _, _, 0).
+choose([[Prob, Head, Body]|Tail], Head1, Body1, Akk, Rand, Rest) :-
+    Akknew is Akk + Prob,
+    choose(Tail, Head1, Body1, Akknew, Rand, Rest1),
+    Rest is Rest1 + Prob,
+    ((var(Body1),
+        Prob1 is Akk/(Akk+Rest), Rand >= P1, Head1 = Head, Body1 = Body);
+    true).
+
 % TESTS
 % want: z((q(X), p(X)), W) === 0.46
 0.6 :: p(a).
@@ -115,4 +145,4 @@ z(G, Weight) :-
 0.1 :: s(a, c).
 0.2 :: s(b, b).
 0.2 :: r(b, Z) :- p(Z).
-0.8 :: r(a, b).
\ No newline at end of file
+0.8 :: r(a, b).

commit 59d9a9db4bbb534cf07cfd94523859932504c1e4
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Tue Sep 12 21:18:46 2023 +0200

    improved solution for only permitting ground terms in substitution list/set, saving one recursion; added base case cut for map_singleton and unify_helper: backtracking is reduced to the absolute minimum

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 5e433e1..53bdfed 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -19,24 +19,16 @@ p(G, ArgList, RoundedResult) :-
     round_third(Result, RoundedResult).
 
 % reimplementation of maplist for singleton list [Singleton] applied to arbitrarily long list [Elem|Tail]
-map_singleton(_, _, [], []).
+map_singleton(_, _, [], []) :- !.
 map_singleton(Goal, [Singleton], [Elem|Tail], [ResElem|ResTail]) :-
     call(Goal, Singleton, Elem, ResElem),
     map_singleton(Goal, [Singleton], Tail, ResTail).
 
 
-% removes non grounded terms from given list
-remove_nongrounds([], []).
-remove_nongrounds([Head|Tail], [Head|ResTail]) :-
-    ground(Head),
-    remove_nongrounds(Tail, ResTail).
-remove_nongrounds([_|Tail], ResTail) :-
-    remove_nongrounds(Tail, ResTail).
-
 % propagates bindings of CurrentGoal to RemainingGoal
 % the List in the form [X=a, Y=b, ...]
 % https://stackoverflow.com/a/64722773
-unify_helper(_, []).
+unify_helper(_, []) :- !.
 unify_helper(Term, [Var=Binding|BagTail]) :-
     findall(Term, Var=Binding, [Term]),
     unify_helper(Term, BagTail).
@@ -95,10 +87,9 @@ z((G1, G2), Weight) :-
         z(G2, Weight2),
         Weight is Weight1*Weight2
     % shared variables --> computation of splitting substitution set
-    ;   findall(SharedVars, clause((_ :: G1), _), SubstitList),
-        list_to_set(SubstitList, SubstitSetCandidates),
-        % non ground terms do not actually make goals disjunct --> therefore removed
-        remove_nongrounds(SubstitSetCandidates, SubstitSet),
+    ;   % only ground terms make goals disjunct
+        findall(SharedVars, (clause((_ :: G1), _), ground(SharedVars)), SubstitList),
+        list_to_set(SubstitList, SubstitSet),
         map_singleton(unifiable, [SharedVars], SubstitSet, PairedVarBindings),
         substitSet_rec(G1, G2, PairedVarBindings, Weight)        
     ).

commit 8eea078199ad6d617d507f021c4283432b72fe3e
Merge: ab49f19 26bd750
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Tue Sep 12 19:57:50 2023 +0200

    deleting test case

commit ab49f19ea62461ad62eea1a4a8e6f5fcc7747f64
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Tue Sep 12 19:55:36 2023 +0200

    removing non ground terms from substitution set as they do not make goals disjoint after binding

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 48d23ca..7075f06 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -24,6 +24,15 @@ map_singleton(Goal, [Singleton], [Elem|Tail], [ResElem|ResTail]) :-
     call(Goal, Singleton, Elem, ResElem),
     map_singleton(Goal, [Singleton], Tail, ResTail).
 
+
+% removes non grounded terms from given list
+remove_nongrounds([], []).
+remove_nongrounds([Head|Tail], [Head|ResTail]) :-
+    ground(Head),
+    remove_nongrounds(Tail, ResTail).
+remove_nongrounds([_|Tail], ResTail) :-
+    remove_nongrounds(Tail, ResTail).
+
 % propagates bindings of CurrentGoal to RemainingGoal
 % the List in the form [X=a, Y=b, ...]
 % https://stackoverflow.com/a/64722773
@@ -41,7 +50,7 @@ unifSet_rec(_, _, [], 0) :- !. % base case cut: prevents further backtracking an
 unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk) :-
     % unifSet_rec recursion requires all subgoals to be as unbound as possible
     % free variable relations must be preserved, e.g. p(X), q(X) must become p(Y), q(Y)
-    copy_term((CurrentGoal,RemainingGoal), (CurrentGoalFree,RemainingGoalFree)),
+    copy_term((CurrentGoal,RemainingGoal, UnifSetTail), (CurrentGoalFree,RemainingGoalFree, UnifSetTailFree)),
 
     nth0(0, UnifClause, ClauseProb),
     nth0(1, UnifClause, ClauseHead),
@@ -49,7 +58,7 @@ unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk) :-
     unifiable(ClauseHead, CurrentGoal, UnifBag),
     unify_helper(RemainingGoal, UnifBag), % how should unify_helper behave if variables in UnifBag have more unification options?
     z((ClauseBody, RemainingGoal), Weight),
-    unifSet_rec(CurrentGoalFree, RemainingGoalFree, UnifSetTail, Akknew),
+    unifSet_rec(CurrentGoalFree, RemainingGoalFree, UnifSetTailFree, Akknew),
     Akk is ClauseProb*Weight + Akknew.
 
 substitSet_rec(_, _, [], 0) :- !. % base case cut: prevents further backtracking and final output "false"
@@ -87,7 +96,9 @@ z((G1, G2), Weight) :-
         Weight is Weight1*Weight2
     % shared variables --> computation of splitting substitution set
     ;   findall(SharedVars, clause((_ :: G1), _), SubstitList),
-        list_to_set(SubstitList, SubstitSet),
+        list_to_set(SubstitList, SubstitSetCandidates),
+        % non ground terms do not actually make goals disjunct --> therefore removed
+        remove_nongrounds(SubstitSetCandidates, SubstitSet),
         map_singleton(unifiable, [SharedVars], SubstitSet, PairedVarBindings),
         substitSet_rec(G1, G2, PairedVarBindings, Weight)        
     ).
@@ -110,6 +121,7 @@ z(G, Weight) :-
 
 0.7 :: s(X, b) :- q(X).
 0.1 :: s(a, c).
-0.2 :: s(d, b).
+0.2 :: s(b, b).
 0.2 :: r(b, Z) :- p(Z).
 0.8 :: r(a, b).
+

commit 26bd75043e3d4143a12d17948b041079a37f4eee
Author: mxs <mxs@dismail.de>
Date:   Tue Sep 12 19:35:11 2023 +0200

    fix test case

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index a7d09d3..da37879 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -116,8 +116,7 @@ z(G, Weight) :-
 0.8 :: r(a, b).
 
 % want: z(ss(X), W) === 0.58
-% have: 0.51 (0.7*0.3 + 0.3)
-0.7 :: ss(a) :- q(a).
+0.7 :: ss(a) :- qq(a).
 0.3 :: ss(b).
 0.4 :: qq(a).
 0.6 :: qq(b).

commit 26e8e5e848a13431e081f95f7934e0dced5e7a8c
Author: mxs <mxs@dismail.de>
Date:   Tue Sep 12 18:50:41 2023 +0200

    add a failing test case

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 48d23ca..a7d09d3 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -103,6 +103,7 @@ z(G, Weight) :-
 
 
 % TESTS
+% want: z((q(X), p(X)), W) === 0.46
 0.6 :: p(a).
 0.4 :: p(b).
 0.3 :: q(a).
@@ -113,3 +114,10 @@ z(G, Weight) :-
 0.2 :: s(d, b).
 0.2 :: r(b, Z) :- p(Z).
 0.8 :: r(a, b).
+
+% want: z(ss(X), W) === 0.58
+% have: 0.51 (0.7*0.3 + 0.3)
+0.7 :: ss(a) :- q(a).
+0.3 :: ss(b).
+0.4 :: qq(a).
+0.6 :: qq(b).

commit 14f4eb7599933de1206bc42166db4ba55a6e5fa8
Author: mxs <mxs@dismail.de>
Date:   Tue Sep 12 18:37:17 2023 +0200

    only round once
    remove a cut
    add a comment for unify_helper

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index bc01fb0..48d23ca 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -6,23 +6,17 @@
 %   normalized SLP (all clauses forming a predicate add up to 1)
 %   pure SLP (no non-prob. clauses)
 
-% invariant helper
-err(X) :-
-    % TODO: print an error message
-    write(user_error, "broken invariant"),
-    halt.
-
 % assumptions:
 %   G is the goal with only free variables
 %   G is non-compound; TODO: assert user input as clause and retract later
 %   ArgList contains the instantiated parameters for G
-p(G, ArgList, Result) :-
+p(G, ArgList, RoundedResult) :-
     functor(G, Functor, Arity),
-    ( length(ArgList, Len), Len \= Arity -> err(Len) ; true ),
     GInstantiated =.. [Functor|ArgList],
     z(GInstantiated, Numerator),
     z(G, Denominator),
-    Result is Numerator / Denominator.
+    Result is Numerator / Denominator,
+    round_third(Result, RoundedResult).
 
 % reimplementation of maplist for singleton list [Singleton] applied to arbitrarily long list [Elem|Tail]
 map_singleton(_, _, [], []).
@@ -32,7 +26,8 @@ map_singleton(Goal, [Singleton], [Elem|Tail], [ResElem|ResTail]) :-
 
 % propagates bindings of CurrentGoal to RemainingGoal
 % the List in the form [X=a, Y=b, ...]
-unify_helper(_, []) :- !.
+% https://stackoverflow.com/a/64722773
+unify_helper(_, []).
 unify_helper(Term, [Var=Binding|BagTail]) :-
     findall(Term, Var=Binding, [Term]),
     unify_helper(Term, BagTail).
@@ -42,9 +37,8 @@ round_third(Float, RoundedFloat) :-
     RoundedScaled is round(Float*1000),
     RoundedFloat is RoundedScaled/1000. 
 
-
 unifSet_rec(_, _, [], 0) :- !. % base case cut: prevents further backtracking and final output "false"
-unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], RoundedAkk) :-
+unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk) :-
     % unifSet_rec recursion requires all subgoals to be as unbound as possible
     % free variable relations must be preserved, e.g. p(X), q(X) must become p(Y), q(Y)
     copy_term((CurrentGoal,RemainingGoal), (CurrentGoalFree,RemainingGoalFree)),
@@ -56,11 +50,10 @@ unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], RoundedAkk) :-
     unify_helper(RemainingGoal, UnifBag), % how should unify_helper behave if variables in UnifBag have more unification options?
     z((ClauseBody, RemainingGoal), Weight),
     unifSet_rec(CurrentGoalFree, RemainingGoalFree, UnifSetTail, Akknew),
-    Akk is ClauseProb*Weight + Akknew,
-    round_third(Akk, RoundedAkk).
+    Akk is ClauseProb*Weight + Akknew.
 
 substitSet_rec(_, _, [], 0) :- !. % base case cut: prevents further backtracking and final output "false"
-substitSet_rec(CurrentGoal, RemainingGoal, [Substitutions|PairedVarBindingsTail], RoundedAkk) :-
+substitSet_rec(CurrentGoal, RemainingGoal, [Substitutions|PairedVarBindingsTail], Akk) :-
     % substitSet_rec recursion requires all subgoals to be as unbound as possible
     % PairedVarBindings must also remain unbound, e.g. old: [X=a], [X=b] becomes [Y=b] instead of [a=b]
     % free variable relations must be preserved, e.g. p(X), q(X) must become p(Y), q(Y)
@@ -71,12 +64,10 @@ substitSet_rec(CurrentGoal, RemainingGoal, [Substitutions|PairedVarBindingsTail]
     z(CurrentGoal, Weight1),
     z(RemainingGoal, Weight2),
     substitSet_rec(CurrentGoalFree, RemainingGoalFree, PairedVarBindingsTailFree, Akknew),
-    Akk is Weight1*Weight2 + Akknew,
-    round_third(Akk, RoundedAkk).
-
+    Akk is Weight1*Weight2 + Akknew.
 
 % base case
-z(true, 1) :- !. % base case cut: prevents further backtracking and final output "false"
+z(true, 1).
 
 % compound base cases; simplifying conjunction
 % base case cuts: prevent further backtracking and final output "false"

commit f232000a8c9dd4df593213f80dd5a1db8f172a37
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Tue Sep 12 16:11:26 2023 +0200

    including optimisations for z() computation; naive approach for substitution set computation

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index e6490ed..bc01fb0 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -24,21 +24,11 @@ p(G, ArgList, Result) :-
     z(G, Denominator),
     Result is Numerator / Denominator.
 
-aux(_, _, [], 0) :- !. % base case cut: prevents further backtracking and final output "false"
-aux(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], RoundedAkk) :-
-    % aux recursion requires all subgoals to be as unbound as possible
-    % free variable relations must be preserved, e.g. p(X), q(X) must become p(Y), q(Y)
-    copy_term((CurrentGoal,RemainingGoal), (CurrentGoalFree,RemainingGoalFree)),
-
-    nth0(0, UnifClause, ClauseProb),
-    nth0(1, UnifClause, ClauseHead),
-    nth0(2, UnifClause, ClauseBody),
-    unifiable(ClauseHead, CurrentGoal, UnifBag),
-    unify_helper(RemainingGoal, UnifBag), % how should unify_helper behave if variables in UnifBag have more unification options?
-    z((ClauseBody, RemainingGoal), Weight),
-    aux(CurrentGoalFree, RemainingGoalFree, UnifSetTail, Akknew),
-    Akk is ClauseProb*Weight + Akknew,
-    round_third(Akk, RoundedAkk).
+% reimplementation of maplist for singleton list [Singleton] applied to arbitrarily long list [Elem|Tail]
+map_singleton(_, _, [], []).
+map_singleton(Goal, [Singleton], [Elem|Tail], [ResElem|ResTail]) :-
+    call(Goal, Singleton, Elem, ResElem),
+    map_singleton(Goal, [Singleton], Tail, ResTail).
 
 % propagates bindings of CurrentGoal to RemainingGoal
 % the List in the form [X=a, Y=b, ...]
@@ -53,23 +43,63 @@ round_third(Float, RoundedFloat) :-
     RoundedFloat is RoundedScaled/1000. 
 
 
+unifSet_rec(_, _, [], 0) :- !. % base case cut: prevents further backtracking and final output "false"
+unifSet_rec(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], RoundedAkk) :-
+    % unifSet_rec recursion requires all subgoals to be as unbound as possible
+    % free variable relations must be preserved, e.g. p(X), q(X) must become p(Y), q(Y)
+    copy_term((CurrentGoal,RemainingGoal), (CurrentGoalFree,RemainingGoalFree)),
+
+    nth0(0, UnifClause, ClauseProb),
+    nth0(1, UnifClause, ClauseHead),
+    nth0(2, UnifClause, ClauseBody),
+    unifiable(ClauseHead, CurrentGoal, UnifBag),
+    unify_helper(RemainingGoal, UnifBag), % how should unify_helper behave if variables in UnifBag have more unification options?
+    z((ClauseBody, RemainingGoal), Weight),
+    unifSet_rec(CurrentGoalFree, RemainingGoalFree, UnifSetTail, Akknew),
+    Akk is ClauseProb*Weight + Akknew,
+    round_third(Akk, RoundedAkk).
+
+substitSet_rec(_, _, [], 0) :- !. % base case cut: prevents further backtracking and final output "false"
+substitSet_rec(CurrentGoal, RemainingGoal, [Substitutions|PairedVarBindingsTail], RoundedAkk) :-
+    % substitSet_rec recursion requires all subgoals to be as unbound as possible
+    % PairedVarBindings must also remain unbound, e.g. old: [X=a], [X=b] becomes [Y=b] instead of [a=b]
+    % free variable relations must be preserved, e.g. p(X), q(X) must become p(Y), q(Y)
+    copy_term((CurrentGoal,RemainingGoal, PairedVarBindingsTail), (CurrentGoalFree,RemainingGoalFree, PairedVarBindingsTailFree)),
+
+    unify_helper(CurrentGoal, Substitutions),
+    unify_helper(RemainingGoal, Substitutions),
+    z(CurrentGoal, Weight1),
+    z(RemainingGoal, Weight2),
+    substitSet_rec(CurrentGoalFree, RemainingGoalFree, PairedVarBindingsTailFree, Akknew),
+    Akk is Weight1*Weight2 + Akknew,
+    round_third(Akk, RoundedAkk).
+
+
 % base case
 z(true, 1) :- !. % base case cut: prevents further backtracking and final output "false"
 
-% compound base case; simplifying conjunction
-z((true, G), Weight) :- z(G, Weight), !. % base case cut: prevents further backtracking and final output "false"
+% compound base cases; simplifying conjunction
+% base case cuts: prevent further backtracking and final output "false"
+z((G, true), Weight) :- z(G, Weight), !. % fires for G as body of a non-compound head
+z((true, G), Weight) :- z(G, Weight), !.
 
 % compound head
 z((G1, G2), Weight) :-
-    % if we share no variables, compute by decomposing
-    % z(G1, Weight1),
-    % z(G2, Weight2),
-    % Weight is Weight1*Weight2,
-
-    % assume we share some variables:
     G1 \= true, % mutual exclusivity of goals
-    findall([Prob, G1, Body], clause((Prob :: G1), Body), UnifSet),
-    aux(G1, G2, UnifSet, Weight).
+
+    % shared variable test
+    sub_term_shared_variables(G1, (G1, G2), SharedVars),
+    ( SharedVars = [] 
+    % no shared variables --> decomposition
+    ->  z(G1, Weight1),
+        z(G2, Weight2),
+        Weight is Weight1*Weight2
+    % shared variables --> computation of splitting substitution set
+    ;   findall(SharedVars, clause((_ :: G1), _), SubstitList),
+        list_to_set(SubstitList, SubstitSet),
+        map_singleton(unifiable, [SharedVars], SubstitSet, PairedVarBindings),
+        substitSet_rec(G1, G2, PairedVarBindings, Weight)        
+    ).
 
 % non-compound head
 z(G, Weight) :-
@@ -78,7 +108,7 @@ z(G, Weight) :-
     G \= true,
 
     findall([Prob, G, Body], clause((Prob :: G), Body), UnifSet),
-    aux(G, true, UnifSet, Weight).
+    unifSet_rec(G, true, UnifSet, Weight).
 
 
 % TESTS
@@ -86,3 +116,9 @@ z(G, Weight) :-
 0.4 :: p(b).
 0.3 :: q(a).
 0.7 :: q(b).
+
+0.7 :: s(X, b) :- q(X).
+0.1 :: s(a, c).
+0.2 :: s(d, b).
+0.2 :: r(b, Z) :- p(Z).
+0.8 :: r(a, b).

commit 23a80396a2a15cd6358a36596f9d12cad7d3da4e
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Tue Sep 12 10:14:24 2023 +0200

    making z() clauses mutually exclusive, adding base case cuts to prevent final answer false, rounding result to three decimals

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 7871353..e6490ed 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -24,10 +24,8 @@ p(G, ArgList, Result) :-
     z(G, Denominator),
     Result is Numerator / Denominator.
 
-
-aux(_, _, [], 0).
-
-aux(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk) :-
+aux(_, _, [], 0) :- !. % base case cut: prevents further backtracking and final output "false"
+aux(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], RoundedAkk) :-
     % aux recursion requires all subgoals to be as unbound as possible
     % free variable relations must be preserved, e.g. p(X), q(X) must become p(Y), q(Y)
     copy_term((CurrentGoal,RemainingGoal), (CurrentGoalFree,RemainingGoalFree)),
@@ -39,22 +37,27 @@ aux(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk) :-
     unify_helper(RemainingGoal, UnifBag), % how should unify_helper behave if variables in UnifBag have more unification options?
     z((ClauseBody, RemainingGoal), Weight),
     aux(CurrentGoalFree, RemainingGoalFree, UnifSetTail, Akknew),
-    Akk is ClauseProb*Weight + Akknew.
-
+    Akk is ClauseProb*Weight + Akknew,
+    round_third(Akk, RoundedAkk).
 
 % propagates bindings of CurrentGoal to RemainingGoal
 % the List in the form [X=a, Y=b, ...]
-unify_helper(_, []).
+unify_helper(_, []) :- !.
 unify_helper(Term, [Var=Binding|BagTail]) :-
     findall(Term, Var=Binding, [Term]),
     unify_helper(Term, BagTail).
 
+% rounding result to third decimal
+round_third(Float, RoundedFloat) :-
+    RoundedScaled is round(Float*1000),
+    RoundedFloat is RoundedScaled/1000. 
+
 
 % base case
-z(true, 1).
+z(true, 1) :- !. % base case cut: prevents further backtracking and final output "false"
 
 % compound base case; simplifying conjunction
-z((true, G), Weight) :- z(G, Weight).
+z((true, G), Weight) :- z(G, Weight), !. % base case cut: prevents further backtracking and final output "false"
 
 % compound head
 z((G1, G2), Weight) :-
@@ -64,13 +67,16 @@ z((G1, G2), Weight) :-
     % Weight is Weight1*Weight2,
 
     % assume we share some variables:
+    G1 \= true, % mutual exclusivity of goals
     findall([Prob, G1, Body], clause((Prob :: G1), Body), UnifSet),
     aux(G1, G2, UnifSet, Weight).
 
 % non-compound head
 z(G, Weight) :-
+    % mutual exclusivity of goals
     G \= (_, _),
     G \= true,
+
     findall([Prob, G, Body], clause((Prob :: G), Body), UnifSet),
     aux(G, true, UnifSet, Weight).
 

commit a950b98a3f903fc0f2d08fc95fdc98babda6f29d
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Tue Sep 12 09:39:06 2023 +0200

    fixing bug of binding variables too early in aux function

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 0d5d467..7871353 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -26,29 +26,34 @@ p(G, ArgList, Result) :-
 
 
 aux(_, _, [], 0).
+
 aux(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk) :-
+    % aux recursion requires all subgoals to be as unbound as possible
+    % free variable relations must be preserved, e.g. p(X), q(X) must become p(Y), q(Y)
+    copy_term((CurrentGoal,RemainingGoal), (CurrentGoalFree,RemainingGoalFree)),
+
     nth0(0, UnifClause, ClauseProb),
     nth0(1, UnifClause, ClauseHead),
     nth0(2, UnifClause, ClauseBody),
     unifiable(ClauseHead, CurrentGoal, UnifBag),
-    unify_helper(RemainingGoal, UnifBag),
-    z((ClauseBody, RemainingGoal), W),
-    aux(CurrentGoal, RemainingGoal, UnifSetTail, Akknew),
-    Akk is Akknew + W*ClauseProb.
-
+    unify_helper(RemainingGoal, UnifBag), % how should unify_helper behave if variables in UnifBag have more unification options?
+    z((ClauseBody, RemainingGoal), Weight),
+    aux(CurrentGoalFree, RemainingGoalFree, UnifSetTail, Akknew),
+    Akk is ClauseProb*Weight + Akknew.
 
 
+% propagates bindings of CurrentGoal to RemainingGoal
 % the List in the form [X=a, Y=b, ...]
 unify_helper(_, []).
-unify_helper(Term, [L=R|BT]) :-
-    findall(Term, L=R, [Term]),
-    unify_helper(Term, BT).
+unify_helper(Term, [Var=Binding|BagTail]) :-
+    findall(Term, Var=Binding, [Term]),
+    unify_helper(Term, BagTail).
 
 
 % base case
 z(true, 1).
 
-% compound base case
+% compound base case; simplifying conjunction
 z((true, G), Weight) :- z(G, Weight).
 
 % compound head

commit 292967bc298f9e642eae8cb44e3aec5ca1979535
Author: mxs <mxs@dismail.de>
Date:   Sun Sep 10 16:04:54 2023 +0200

    findall unification; but base cases are off
    
    delete old debug log

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 082473e..0d5d467 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -24,18 +24,33 @@ p(G, ArgList, Result) :-
     z(G, Denominator),
     Result is Numerator / Denominator.
 
-aux(_, [], 0).
 
-aux(RemainingGoal, [UnifClause|UnifSetTail], Akk) :-
+aux(_, _, [], 0).
+aux(CurrentGoal, RemainingGoal, [UnifClause|UnifSetTail], Akk) :-
     nth0(0, UnifClause, ClauseProb),
+    nth0(1, UnifClause, ClauseHead),
     nth0(2, UnifClause, ClauseBody),
+    unifiable(ClauseHead, CurrentGoal, UnifBag),
+    unify_helper(RemainingGoal, UnifBag),
     z((ClauseBody, RemainingGoal), W),
-    aux(RemainingGoal, UnifSetTail, Akknew),
+    aux(CurrentGoal, RemainingGoal, UnifSetTail, Akknew),
     Akk is Akknew + W*ClauseProb.
 
+
+
+% the List in the form [X=a, Y=b, ...]
+unify_helper(_, []).
+unify_helper(Term, [L=R|BT]) :-
+    findall(Term, L=R, [Term]),
+    unify_helper(Term, BT).
+
+
 % base case
 z(true, 1).
 
+% compound base case
+z((true, G), Weight) :- z(G, Weight).
+
 % compound head
 z((G1, G2), Weight) :-
     % if we share no variables, compute by decomposing
@@ -44,15 +59,15 @@ z((G1, G2), Weight) :-
     % Weight is Weight1*Weight2,
 
     % assume we share some variables:
-    bagof([Prob, G1, Body], clause((Prob :: G1), Body), UnifSet),
-    aux(G2, UnifSet, Weight).
+    findall([Prob, G1, Body], clause((Prob :: G1), Body), UnifSet),
+    aux(G1, G2, UnifSet, Weight).
 
 % non-compound head
 z(G, Weight) :-
     G \= (_, _),
     G \= true,
-    bagof([Prob, G, Body], clause((Prob :: G), Body), UnifSet),
-    aux(true, UnifSet, Weight).
+    findall([Prob, G, Body], clause((Prob :: G), Body), UnifSet),
+    aux(G, true, UnifSet, Weight).
 
 
 % TESTS
diff --git a/src/debug/broken-inference.log b/src/debug/broken-inference.log
deleted file mode 100644
index 9666c23..0000000
--- a/src/debug/broken-inference.log
+++ /dev/null
@@ -1,115 +0,0 @@
-[trace]  ?- inference_(z(X), P).
-   Call: (10) inference_(z(_14324), _14330) ? creep
-   Call: (11) collect_clauses(z(_14324), true, _14330) ? creep
-^  Call: (12) findall((_16480::z(_14324)), clause((_16480::z(_14324)), true), _16496) ? creep
-^  Exit: (12) findall((_16480::z(_14324)), user:clause((_16480::z(_14324)), true), [(0.1::z(a)), (0.9::z(b))]) ? creep
-^  Call: (12) solution_sequences:group_by(z(_14324), _16480, member((_16480::z(_14324)), [(0.1::z(a)), (0.9::z(b))]), _18240) ? creep
-   Call: (13) solution_sequences:ordered_term_variables(user:member((_16480::z(_14324)), [(0.1::z(a)), (0.9::z(b))]), _20544) ? creep
-   Call: (14) term_variables(user:member((_16480::z(_14324)), [(0.1::z(a)), (0.9::z(b))]), _21368) ? creep
-   Exit: (14) term_variables(user:member((_16480::z(_14324)), [(0.1::z(a)), (0.9::z(b))]), [_16480, _14324]) ? creep
-   Call: (14) sort([_16480, _14324], _20544) ? creep
-   Exit: (14) sort([_16480, _14324], [_14324, _16480]) ? creep
-   Exit: (13) solution_sequences:ordered_term_variables(user:member((_16480::z(_14324)), [(0.1::z(a)), (0.9::z(b))]), [_14324, _16480]) ? creep
-   Call: (13) solution_sequences:ordered_term_variables(z(_14324)+_16480, _25462) ? creep
-   Call: (14) term_variables(z(_14324)+_16480, _26286) ? creep
-   Exit: (14) term_variables(z(_14324)+_16480, [_14324, _16480]) ? creep
-   Call: (14) sort([_14324, _16480], _25462) ? creep
-   Exit: (14) sort([_14324, _16480], [_14324, _16480]) ? creep
-   Exit: (13) solution_sequences:ordered_term_variables(z(_14324)+_16480, [_14324, _16480]) ? creep
-   Call: (13) ordsets:ord_subtract([_18, _94], [_18, _94], _192) ? creep
-   Exit: (13) ordsets:ord_subtract([_18, _94], [_18, _94], []) ? creep
-^  Call: (13) bagof(_94, []^(user:member((_94::z(_18)), [(0.1::z(a)), (0.9::z(b))])), _154) ? creep
-^  Exit: (13) bagof(_94, solution_sequences:[]^(user:member((_94::z(a)), [(0.1::z(a)), (0.9::z(b))])), [0.1]) ? creep
-^  Exit: (12) solution_sequences:group_by(z(a), _94, user:member((_94::z(a)), [(0.1::z(a)), (0.9::z(b))]), [0.1]) ? creep
-   Call: (12) lists:sum_list([0.1], _20) ? creep
-   Exit: (12) lists:sum_list([0.1], 0.1) ? creep
-   Exit: (11) collect_clauses(z(a), true, 0.1) ? creep
-   Exit: (10) inference_(z(a), 0.1) ? creep
-X = a,
-P = 0.1 ;
-^  Redo: (13) bagof(_94, solution_sequences:[]^(user:member((_94::z(_18)), [(0.1::z(a)), (0.9::z(b))])), _154) ? creep
-^  Exit: (13) bagof(_94, solution_sequences:[]^(user:member((_94::z(b)), [(0.1::z(a)), (0.9::z(b))])), [0.9]) ? creep
-^  Exit: (12) solution_sequences:group_by(z(b), _94, user:member((_94::z(b)), [(0.1::z(a)), (0.9::z(b))]), [0.9]) ? creep
-   Call: (12) lists:sum_list([0.9], _20) ? creep
-   Exit: (12) lists:sum_list([0.9], 0.9) ? creep
-   Exit: (11) collect_clauses(z(b), true, 0.9) ? creep
-   Exit: (10) inference_(z(b), 0.9) ? creep
-X = b,
-P = 0.9 ;
-   Redo: (10) inference_(z(_18), _20) ? creep
-   Call: (11) collect_clauses(z(_18), _25828, _25830) ? creep
-^  Call: (12) findall((_26648::z(_18)), clause((_26648::z(_18)), _25828), _26664) ? creep
-^  Exit: (12) findall((_26648::z(_18)), user:clause((_26648::z(_18)), _25828), [(0.1::z(a)), (0.9::z(b))]) ? creep
-^  Call: (12) solution_sequences:group_by(z(_18), _26648, member((_26648::z(_18)), [(0.1::z(a)), (0.9::z(b))]), _28408) ? creep
-   Call: (13) solution_sequences:ordered_term_variables(user:member((_26648::z(_18)), [(0.1::z(a)), (0.9::z(b))]), _29252) ? creep
-   Call: (14) term_variables(user:member((_26648::z(_18)), [(0.1::z(a)), (0.9::z(b))]), _30076) ? creep
-   Exit: (14) term_variables(user:member((_26648::z(_18)), [(0.1::z(a)), (0.9::z(b))]), [_26648, _18]) ? creep
-   Call: (14) sort([_26648, _18], _29252) ? creep
-   Exit: (14) sort([_26648, _18], [_18, _26648]) ? creep
-   Exit: (13) solution_sequences:ordered_term_variables(user:member((_26648::z(_18)), [(0.1::z(a)), (0.9::z(b))]), [_18, _26648]) ? creep
-   Call: (13) solution_sequences:ordered_term_variables(z(_18)+_26648, _34170) ? creep
-   Call: (14) term_variables(z(_18)+_26648, _34994) ? creep
-   Exit: (14) term_variables(z(_18)+_26648, [_18, _26648]) ? creep
-   Call: (14) sort([_18, _26648], _34170) ? creep
-   Exit: (14) sort([_18, _26648], [_18, _26648]) ? creep
-   Exit: (13) solution_sequences:ordered_term_variables(z(_18)+_26648, [_18, _26648]) ? creep
-   Call: (13) ordsets:ord_subtract([_18, _26648], [_18, _26648], _39082) ? creep
-   Exit: (13) ordsets:ord_subtract([_18, _26648], [_18, _26648], []) ? creep
-^  Call: (13) bagof(_26648, []^(user:member((_26648::z(_18)), [(0.1::z(a)), (0.9::z(b))])), _28408) ? creep
-^  Exit: (13) bagof(_26648, solution_sequences:[]^(user:member((_26648::z(a)), [(0.1::z(a)), (0.9::z(b))])), [0.1]) ? creep
-^  Exit: (12) solution_sequences:group_by(z(a), _26648, user:member((_26648::z(a)), [(0.1::z(a)), (0.9::z(b))]), [0.1]) ? creep
-   Call: (12) lists:sum_list([0.1], _25830) ? creep
-   Exit: (12) lists:sum_list([0.1], 0.1) ? creep
-   Exit: (11) collect_clauses(z(a), _25828, 0.1) ? creep
-   Call: (11) _25828=(_45864, _45866) ? creep
-   Exit: (11) (_45864, _45866)=(_45864, _45866) ? creep
-   Call: (11) inference_(_45864, _47488) ? creep
-   Exit: (11) inference_(true, 1) ? creep
-   Call: (11) inference_(_45866, _49110) ? creep
-   Exit: (11) inference_(true, 1) ? creep
-   Call: (11) _20 is 0.1*1*1 ? creep
-   Exit: (11) 0.1 is 0.1*1*1 ? creep
-   Exit: (10) inference_(z(a), 0.1) ? creep
-X = a,
-P = 0.1 ;
-   Redo: (11) inference_(_45866, _49110) ? creep
-   Call: (12) collect_clauses(_45866, true, _49110) ? creep
-^  Call: (13) findall((_56716::_45866), clause((_56716::_45866), true), _56732) ? creep
-^  Exit: (13) findall((_56716::_45866), user:clause((_56716::_45866), true), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(a)), (0.9::r(b)), (0.0::p(a)), (0.1::p(...)), (... :: ...)|...]) ? creep
-^  Call: (13) solution_sequences:group_by(_45866, _56716, member((_56716::_45866), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(a)), (0.9::r(...)), (... :: ...)|...]), _59204) ? creep
-   Call: (14) solution_sequences:ordered_term_variables(user:member((_56716::_45866), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(...)), (... :: ...)|...]), _60048) ? creep
-   Call: (15) term_variables(user:member((_56716::_45866), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(a)), (0.9::r(...)), (... :: ...)|...]), _60872) ? creep
-   Exit: (15) term_variables(user:member((_56716::_45866), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(a)), (0.9::r(...)), (... :: ...)|...]), [_56716, _45866]) ? creep
-   Call: (15) sort([_56716, _45866], _60048) ? creep
-   Exit: (15) sort([_56716, _45866], [_45866, _56716]) ? creep
-   Exit: (14) solution_sequences:ordered_term_variables(user:member((_56716::_45866), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(...)), (... :: ...)|...]), [_45866, _56716]) ? creep
-   Call: (14) solution_sequences:ordered_term_variables(_45866+_56716, _64966) ? creep
-   Call: (15) term_variables(_45866+_56716, _65790) ? creep
-   Exit: (15) term_variables(_45866+_56716, [_45866, _56716]) ? creep
-   Call: (15) sort([_45866, _56716], _64966) ? creep
-   Exit: (15) sort([_45866, _56716], [_45866, _56716]) ? creep
-   Exit: (14) solution_sequences:ordered_term_variables(_45866+_56716, [_45866, _56716]) ? creep
-   Call: (14) ordsets:ord_subtract([_45866, _56716], [_45866, _56716], _69878) ? creep
-   Exit: (14) ordsets:ord_subtract([_45866, _56716], [_45866, _56716], []) ? creep
-^  Call: (14) bagof(_56716, []^(user:member((_56716::_45866), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(...)), (... :: ...)|...])), _59204) ? creep
-^  Exit: (14) bagof(_56716, solution_sequences:[]^(user:member((_56716::fact), [(0.2::q(a)), (0.1::q(b)), (0.4::q(...)), (... :: ...)|...])), [1/2]) ? creep
-^  Exit: (13) solution_sequences:group_by(fact, _56716, user:member((_56716::fact), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(...)), (... :: ...)|...]), [1/2]) ? creep
-   Call: (13) lists:sum_list([1/2], _49110) ? creep
-   Exit: (13) lists:sum_list([1/2], 0.5) ? creep
-   Exit: (12) collect_clauses(fact, true, 0.5) ? creep
-   Exit: (11) inference_(fact, 0.5) ? creep
-   Call: (11) _20 is 0.1*1*0.5 ? creep
-   Exit: (11) 0.05 is 0.1*1*0.5 ? creep
-   Exit: (10) inference_(z(a), 0.05) ? creep
-X = a,
-P = 0.05 ;
-^  Redo: (14) bagof(_56716, solution_sequences:[]^(user:member((_56716::_45866), [(0.2::q(a)), (0.1::q(b)), (0.4::q(...)), (... :: ...)|...])), _59204) ? creep
-^  Exit: (14) bagof(_56716, solution_sequences:[]^(user:member((_56716::fact1), [(0.2::q(a)), (0.1::q(b)), (0.4::q(...)), (... :: ...)|...])), [1]) ? creep
-^  Exit: (13) solution_sequences:group_by(fact1, _56716, user:member((_56716::fact1), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(...)), (... :: ...)|...]), [1]) ? creep
-   Call: (13) lists:sum_list([1], _49110) ? creep
-   Exit: (13) lists:sum_list([1], 1) ? creep
-   Exit: (12) collect_clauses(fact1, true, 1) ? creep
-   Exit: (11) inference_(fact1, 1) ? creep
-   Call: (11) _20 is 0.1*1*1 ? creep
-   Exit: (11) 0.1 is 0.1*1*1 ? creep
-   Exit: (10) inference_(z(a), 0.1) ?
diff --git a/src/debug/failure-patternmatching.log b/src/debug/failure-patternmatching.log
new file mode 100644
index 0000000..67e9e25
--- /dev/null
+++ b/src/debug/failure-patternmatching.log
@@ -0,0 +1,134 @@
+[trace]  ?- z((p(X), q(X)), W).
+   Call: (10) z((p(_19628), q(_19628)), _19644) ? creep
+^  Call: (11) findall([_21004, p(_19628), _21016], clause((_21004::p(_19628)), _21016), _21032) ? creep
+^  Exit: (11) findall([_21004, p(_19628), _21016], user:clause((_21004::p(_19628)), _21016), [[0.6, p(a), true], [0.4, p(b), true]]) ? creep
+   Call: (11) aux(p(_19628), q(_19628), [[0.6, p(a), true], [0.4, p(b), true]], _19644) ? creep
+   Call: (12) lists:nth0(0, [0.6, p(a), true], _23606) ? creep
+   Exit: (12) lists:nth0(0, [0.6, p(a), true], 0.6) ? creep
+   Call: (12) lists:nth0(1, [0.6, p(a), true], _25264) ? creep
+   Exit: (12) lists:nth0(1, [0.6, p(a), true], p(a)) ? creep
+   Call: (12) lists:nth0(2, [0.6, p(a), true], _26922) ? creep
+   Exit: (12) lists:nth0(2, [0.6, p(a), true], true) ? creep
+   Call: (12) unifiable(p(a), p(_19628), _28580) ? creep
+   Exit: (12) unifiable(p(a), p(_19628), [_19628=a]) ? creep
+   Call: (12) unify_helper(q(_19628), [_19628=a]) ? creep
+^  Call: (13) findall(q(_19628), _19628=a, [q(_19628)]) ? creep
+^  Exit: (13) findall(q(a), user:(a=a), [q(a)]) ? creep
+   Call: (13) unify_helper(q(a), []) ? creep
+   Exit: (13) unify_helper(q(a), []) ? creep
+   Exit: (12) unify_helper(q(a), [a=a]) ? creep
+   Call: (12) z((true, q(a)), _35178) ? creep
+   Call: (13) z(q(a), _35178) ? creep
+   Call: (14) q(a)\=(_36802, _36804) ? creep
+   Exit: (14) q(a)\=(_36802, _36804) ? creep
+   Call: (14) q(a)\=true ? creep
+   Exit: (14) q(a)\=true ? creep
+^  Call: (14) findall([_40048, q(a), _40060], clause((_40048::q(a)), _40060), _40076) ? creep
+^  Exit: (14) findall([_40048, q(a), _40060], user:clause((_40048::q(a)), _40060), [[0.3, q(a), true]]) ? creep
+   Call: (14) aux(q(a), true, [[0.3, q(a), true]], _35178) ? creep
+   Call: (15) lists:nth0(0, [0.3, q(a), true], _42616) ? creep
+   Exit: (15) lists:nth0(0, [0.3, q(a), true], 0.3) ? creep
+   Call: (15) lists:nth0(1, [0.3, q(a), true], _44274) ? creep
+   Exit: (15) lists:nth0(1, [0.3, q(a), true], q(a)) ? creep
+   Call: (15) lists:nth0(2, [0.3, q(a), true], _45932) ? creep
+   Exit: (15) lists:nth0(2, [0.3, q(a), true], true) ? creep
+   Call: (15) unifiable(q(a), q(a), _47590) ? creep
+   Exit: (15) unifiable(q(a), q(a), []) ? creep
+   Call: (15) unify_helper(true, []) ? creep
+   Exit: (15) unify_helper(true, []) ? creep
+   Call: (15) z((true, true), _50846) ? creep
+   Call: (16) z(true, _50846) ? creep
+   Exit: (16) z(true, 1) ? creep
+   Exit: (15) z((true, true), 1) ? creep
+   Call: (15) aux(q(a), true, [], _54088) ? creep
+   Exit: (15) aux(q(a), true, [], 0) ? creep
+   Call: (15) _35178 is 0+1*0.3 ? creep
+   Exit: (15) 0.3 is 0+1*0.3 ? creep
+   Exit: (14) aux(q(a), true, [[0.3, q(a), true]], 0.3) ? creep
+   Exit: (13) z(q(a), 0.3) ? creep
+   Exit: (12) z((true, q(a)), 0.3) ? creep
+   Call: (12) aux(p(a), q(a), [[0.4, p(b), true]], _59802) ? creep
+   Call: (13) lists:nth0(0, [0.4, p(b), true], _60622) ? creep
+   Exit: (13) lists:nth0(0, [0.4, p(b), true], 0.4) ? creep
+   Call: (13) lists:nth0(1, [0.4, p(b), true], _62280) ? creep
+   Exit: (13) lists:nth0(1, [0.4, p(b), true], p(b)) ? creep
+   Call: (13) lists:nth0(2, [0.4, p(b), true], _63938) ? creep
+   Exit: (13) lists:nth0(2, [0.4, p(b), true], true) ? creep
+   Call: (13) unifiable(p(b), p(a), _754) ? creep
+   Fail: (13) unifiable(p(b), p(a), _754) ? creep
+   Fail: (12) aux(p(a), q(a), [[0.4, p(b), true]], _270) ? creep
+   Redo: (15) aux(q(a), true, [], _262) ? creep
+   Fail: (15) aux(q(a), true, [], _262) ? creep
+   Redo: (16) z(true, _260) ? creep
+   Call: (17) true\=(_5650, _5652) ? creep
+   Exit: (17) true\=(_5650, _5652) ? creep
+   Call: (17) true\=true ? creep
+   Fail: (17) true\=true ? creep
+   Fail: (16) z(true, _260) ? creep
+   Redo: (15) z((true, true), _260) ? creep
+^  Call: (16) findall([_10516, true, _10528], clause((_10516::true), _10528), _10544) ? creep
+^  Exit: (16) findall([_10516, true, _10528], user:clause((_10516::true), _10528), []) ? creep
+   Call: (16) aux(true, true, [], _260) ? creep
+   Exit: (16) aux(true, true, [], 0) ? creep
+   Exit: (15) z((true, true), 0) ? creep
+   Call: (15) aux(q(a), true, [], _14678) ? creep
+   Exit: (15) aux(q(a), true, [], 0) ? creep
+   Call: (15) _204 is 0+0*0.3 ? creep
+   Exit: (15) 0.0 is 0+0*0.3 ? creep
+   Exit: (14) aux(q(a), true, [[0.3, q(a), true]], 0.0) ? creep
+   Exit: (13) z(q(a), 0.0) ? creep
+   Exit: (12) z((true, q(a)), 0.0) ? creep
+   Call: (12) aux(p(a), q(a), [[0.4, p(b), true]], _20392) ? creep
+   Call: (13) lists:nth0(0, [0.4, p(b), true], _21212) ? creep
+   Exit: (13) lists:nth0(0, [0.4, p(b), true], 0.4) ? creep
+   Call: (13) lists:nth0(1, [0.4, p(b), true], _22870) ? creep
+   Exit: (13) lists:nth0(1, [0.4, p(b), true], p(b)) ? creep
+   Call: (13) lists:nth0(2, [0.4, p(b), true], _24528) ? creep
+   Exit: (13) lists:nth0(2, [0.4, p(b), true], true) ? creep
+   Call: (13) unifiable(p(b), p(a), _26186) ? creep
+   Fail: (13) unifiable(p(b), p(a), _26186) ? creep
+   Fail: (12) aux(p(a), q(a), [[0.4, p(b), true]], _20392) ? creep
+   Redo: (15) aux(q(a), true, [], _14678) ? creep
+   Fail: (15) aux(q(a), true, [], _14678) ? creep
+   Redo: (16) aux(true, true, [], _260) ? creep
+   Fail: (16) aux(true, true, [], _260) ? creep
+   Redo: (15) z((true, true), _260) ? creep
+   Call: (16) (true, true)\=(_32718, _32720) ? creep
+   Fail: (16) (true, true)\=(_32718, _32720) ? creep
+   Fail: (15) z((true, true), _260) ? creep
+   Redo: (15) unify_helper(true, []) ? creep
+   Fail: (15) unify_helper(true, []) ? creep
+   Fail: (14) aux(q(a), true, [[0.3, q(a), true]], _204) ? creep
+   Fail: (13) z(q(a), _204) ? creep
+   Redo: (12) z((true, q(a)), _204) ? creep
+^  Call: (13) findall([_39212, true, _39224], clause((_39212::true), _39224), _39240) ? creep
+^  Exit: (13) findall([_39212, true, _39224], user:clause((_39212::true), _39224), []) ? creep
+   Call: (13) aux(true, q(a), [], _204) ? creep
+   Exit: (13) aux(true, q(a), [], 0) ? creep
+   Exit: (12) z((true, q(a)), 0) ? creep
+   Call: (12) aux(p(a), q(a), [[0.4, p(b), true]], _43374) ? creep
+   Call: (13) lists:nth0(0, [0.4, p(b), true], _44194) ? creep
+   Exit: (13) lists:nth0(0, [0.4, p(b), true], 0.4) ? creep
+   Call: (13) lists:nth0(1, [0.4, p(b), true], _45852) ? creep
+   Exit: (13) lists:nth0(1, [0.4, p(b), true], p(b)) ? creep
+   Call: (13) lists:nth0(2, [0.4, p(b), true], _47510) ? creep
+   Exit: (13) lists:nth0(2, [0.4, p(b), true], true) ? creep
+   Call: (13) unifiable(p(b), p(a), _49168) ? creep
+   Fail: (13) unifiable(p(b), p(a), _49168) ? creep
+   Fail: (12) aux(p(a), q(a), [[0.4, p(b), true]], _43374) ? creep
+   Redo: (13) aux(true, q(a), [], _204) ? creep
+   Fail: (13) aux(true, q(a), [], _204) ? creep
+   Redo: (12) z((true, q(a)), _204) ? creep
+   Call: (13) (true, q(a))\=(_54064, _54066) ? creep
+   Fail: (13) (true, q(a))\=(_54064, _54066) ? creep
+   Fail: (12) z((true, q(a)), _204) ? creep
+   Redo: (13) unify_helper(q(a), []) ? creep
+   Fail: (13) unify_helper(q(a), []) ? creep
+   Fail: (12) unify_helper(q(_18), [_18=a]) ? creep
+   Fail: (11) aux(p(_18), q(_18), [[0.6, p(a), true], [0.4, p(b), true]], _20) ? creep
+   Redo: (10) z((p(_18), q(_18)), _20) ? creep
+   Call: (11) (p(_18), q(_18))\=(_60558, _60560) ? creep
+   Fail: (11) (p(_18), q(_18))\=(_60558, _60560) ? creep
+   Fail: (10) z((p(_18), q(_18)), _20) ? creep
+false.
+

commit a3b9ce4987d6cc59dd4857a040db94c9f46e24d2
Author: mxs <mxs@dismail.de>
Date:   Sun Sep 10 15:08:29 2023 +0200

    simple case of cussens inference.
    
    bug: finall doesn't properly instantiate/bind other occurencies

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 5e6b6e8..082473e 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -24,33 +24,39 @@ p(G, ArgList, Result) :-
     z(G, Denominator),
     Result is Numerator / Denominator.
 
-% head recursion 
-z((G1 ,G2), WeightRes) :-
-    z(G1, Weight1),
-    z(G2, Weight2),
-    WeightRes is Weight1*Weight2.
+aux(_, [], 0).
 
-% body recursion, compound
-z(G, Weight) :-
-    findall([Prob, G, Body], clause((Prob :: G), Body), UnifSet),
-    [UnifClause|UnifSetTail] = UnifSet,
+aux(RemainingGoal, [UnifClause|UnifSetTail], Akk) :-
     nth0(0, UnifClause, ClauseProb),
     nth0(2, UnifClause, ClauseBody),
-    % only non-variable bodies won't cause infinite recursion
-    nonvar(ClauseBody),
-    ClauseBody = (Body1, Body2),
-    z(Body1, W1),
-    z(Body2, W2),
-    Weight is ClauseProb * W1 * W2.
-
-% body recursion, non-compound
+    z((ClauseBody, RemainingGoal), W),
+    aux(RemainingGoal, UnifSetTail, Akknew),
+    Akk is Akknew + W*ClauseProb.
+
+% base case
+z(true, 1).
+
+% compound head
+z((G1, G2), Weight) :-
+    % if we share no variables, compute by decomposing
+    % z(G1, Weight1),
+    % z(G2, Weight2),
+    % Weight is Weight1*Weight2,
+
+    % assume we share some variables:
+    bagof([Prob, G1, Body], clause((Prob :: G1), Body), UnifSet),
+    aux(G2, UnifSet, Weight).
+
+% non-compound head
 z(G, Weight) :-
-    findall([Prob, G, Body], clause((Prob :: G), Body), UnifSet),
-    [UnifClause|UnifSetTail] = UnifSet,
-    nth0(0, UnifClause, ClauseProb),
-    nth0(2, UnifClause, ClauseBody),
-    % only non-variable bodies won't cause infinite recursion
-    ClauseBody \= (Body1, Body2),
-    % TODO: maybe exclude true as well? / base case
-    z(ClauseBody, W),
-    Weight is ClauseProb * W.
+    G \= (_, _),
+    G \= true,
+    bagof([Prob, G, Body], clause((Prob :: G), Body), UnifSet),
+    aux(true, UnifSet, Weight).
+
+
+% TESTS
+0.6 :: p(a).
+0.4 :: p(b).
+0.3 :: q(a).
+0.7 :: q(b).

commit f943585045ef7b65fe8c278ab70de5d412c302c3
Merge: cb6142f 9dc1b4f
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Sun Sep 10 12:40:32 2023 +0200

    Merge branch 'master' of gitlab.lrz.de:000000000135D322/plp

commit cb6142f615f5243dd6a076a806b48ca01cafafd6
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Sun Sep 10 12:40:21 2023 +0200

    test.pl

diff --git a/src/test.pl b/src/test.pl
new file mode 100644
index 0000000..26d9724
--- /dev/null
+++ b/src/test.pl
@@ -0,0 +1,58 @@
+suess(Apfel) :- Apfel, rot(Apfel).
+
+elstar.
+boskop.
+goldendelicious.
+goldparmaene.
+
+rot(elstar).
+rot(goldparmaene).
+
+p(a, b).
+p(b, x).
+q(b).
+r(a, a).
+r(c, d).
+
+
+
+u(X, Y, Z) :- p(X, Y), q(X), r(Z, Z).
+
+exists_member([], V2, noSharing).
+exists_member([Head|Tail], V2, R) :-
+    ( member(Head, V2)
+    -> R = sharing
+    ; exists_member(Tail, V2, R) ).
+
+
+var_equal(G, RG13, RG12, RG23, RG2G3) :-
+    numbervars(G, 0, End),
+    (G1, G2, G3) = G,
+    varnumbers(G1, G1Free),
+    term_variables(G1Free, G1Vars),
+    term_variables(G2, G2Vars),
+    term_variables(G3, G3Vars),
+    term_variables((G2,G3), G2G3Vars),
+    exists_member(G1Vars, G3Vars, RG13),
+    exists_member(G1Vars, G2Vars, RG12),
+    exists_member(G2Vars, G3Vars, RG23),
+    exists_member(G1Vars, G2G3Vars, RG2G3).
+
+var_equal(G, G1Shared, G2Shared, G3Shared) :-
+    (G1, G2, G3) = G,
+    sub_term_shared_variables(G1, G, G1Shared),
+    sub_term_shared_variables(G2, G, G2Shared),
+    sub_term_shared_variables(G3, G, G3Shared).
+
+% rough idea: If GxShared is empty, do recursive splitting as before, i.e. z(G1), z(G\G1) and multiply
+% otherwise: work with list of subgoals!
+%   append new (possibly instantiated) body to list (e.g. as head, order not relevant as we only consider conjunctions so far)
+%   find all subgoals in list sharing the same variable and assign same instantiation to them
+%   call z(transformed_goal) where transformed goal comprises the body replacement and instantiation changes
+
+    
+
+
+
+    
+    
\ No newline at end of file

commit 9dc1b4f981c3706ea415bb7e6998e508c780ebbe
Author: mxs <mxs@dismail.de>
Date:   Sun Sep 10 12:21:59 2023 +0200

    fix recusion bug in v1 inference.
    
    but still wrong probability for some cases

diff --git a/src/metainterp.pl b/src/metainterp.pl
index b6bcd49..7ba6f27 100644
--- a/src/metainterp.pl
+++ b/src/metainterp.pl
@@ -40,7 +40,8 @@ inference_((Goal1; Goal2), ProbRes) :-
 inference_(Rule, ProbRes) :-
     % body is not yet bound, we bind it here
     collect_clauses(Rule, Body, PRet),
-    Body = (Goal1, Goal2), 
+    nonvar(Body),
+    Body = (Goal1, Goal2),
     inference_(Goal1, Prob1),
     inference_(Goal2, Prob2),
     ProbRes is PRet*Prob1*Prob2.
@@ -48,7 +49,8 @@ inference_(Rule, ProbRes) :-
 % body recursion, compound
 inference_(Rule, ProbRes) :-
     collect_clauses(Rule, Body, PRet),
-    Body = (Goal1; Goal2), 
+    nonvar(Body),
+    Body = (Goal1; Goal2),
     inference_(Goal1, Prob1),
     inference_(Goal2, Prob2),
     % this recursion exactly corresponds to the inclusion-exclusion-principle
@@ -142,6 +144,7 @@ stop([Player,Banker],_) :-
 pay_entrance([Player,Banker],[Player-4,Banker+4]).
 dice_reward([Player,Banker],[Player+D,Banker-D]) :- roll_dice(D).
 
+1/6::roll_dice(1).
 1/6::roll_dice(1).
 1/6::roll_dice(2).
 1/6::roll_dice(3).
@@ -230,5 +233,11 @@ dice_reward([Player,Banker],[Player+D,Banker-D]) :- roll_dice(D).
 1/5 :: gl22 :- fail.
 1/5 :: gl22 :- fail.
 
-
+% neuer randfall (und der grund wieso wir bei cussen's exact inference algorithmus den nenner brauchen / wieso er nicht immer 1 ist)
+1/2 :: s(a) :- p(a).
+1/2 :: s(a) :- q(a).
+0.6 :: p(a).
+0.4 :: p(b).
+0.3 :: q(a).
+0.7 :: q(b).
 

commit 502c71dfdc7f17749d7020c25d5afcc8b1b49e69
Author: mxs <mxs@dismail.de>
Date:   Sun Sep 10 12:19:54 2023 +0200

    add Muggleton paper containing information on stochastic clause selector

diff --git a/material/slp.pdf b/material/slp.pdf
new file mode 100644
index 0000000..d2088af
Binary files /dev/null and b/material/slp.pdf differ

commit 7a02421e83d75bfce121831fe9b1daedfe65d9d9
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Sat Sep 9 17:11:37 2023 +0200

    draft for cussens paper implementation; still missing: Instantiating shared variables with computed answer for subgoal; head recursion only correct for goals not sharing variables

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
index 29a6272..5e6b6e8 100644
--- a/src/cussens-inference.pl
+++ b/src/cussens-inference.pl
@@ -24,5 +24,33 @@ p(G, ArgList, Result) :-
     z(G, Denominator),
     Result is Numerator / Denominator.
 
+% head recursion 
+z((G1 ,G2), WeightRes) :-
+    z(G1, Weight1),
+    z(G2, Weight2),
+    WeightRes is Weight1*Weight2.
+
+% body recursion, compound
+z(G, Weight) :-
+    findall([Prob, G, Body], clause((Prob :: G), Body), UnifSet),
+    [UnifClause|UnifSetTail] = UnifSet,
+    nth0(0, UnifClause, ClauseProb),
+    nth0(2, UnifClause, ClauseBody),
+    % only non-variable bodies won't cause infinite recursion
+    nonvar(ClauseBody),
+    ClauseBody = (Body1, Body2),
+    z(Body1, W1),
+    z(Body2, W2),
+    Weight is ClauseProb * W1 * W2.
+
+% body recursion, non-compound
 z(G, Weight) :-
-    ...
+    findall([Prob, G, Body], clause((Prob :: G), Body), UnifSet),
+    [UnifClause|UnifSetTail] = UnifSet,
+    nth0(0, UnifClause, ClauseProb),
+    nth0(2, UnifClause, ClauseBody),
+    % only non-variable bodies won't cause infinite recursion
+    ClauseBody \= (Body1, Body2),
+    % TODO: maybe exclude true as well? / base case
+    z(ClauseBody, W),
+    Weight is ClauseProb * W.

commit 0bee9b43a198f1d786c5c85aa6294e98ef25d5d1
Author: mxs <mxs@dismail.de>
Date:   Sat Sep 9 12:36:01 2023 +0200

    wip: inference v2

diff --git a/src/cussens-inference.pl b/src/cussens-inference.pl
new file mode 100644
index 0000000..29a6272
--- /dev/null
+++ b/src/cussens-inference.pl
@@ -0,0 +1,28 @@
+:- op(1199,xfx,::).
+:- discontiguous (::)/2.
+
+% meta-assumptions:
+%   only conjunctions
+%   normalized SLP (all clauses forming a predicate add up to 1)
+%   pure SLP (no non-prob. clauses)
+
+% invariant helper
+err(X) :-
+    % TODO: print an error message
+    write(user_error, "broken invariant"),
+    halt.
+
+% assumptions:
+%   G is the goal with only free variables
+%   G is non-compound; TODO: assert user input as clause and retract later
+%   ArgList contains the instantiated parameters for G
+p(G, ArgList, Result) :-
+    functor(G, Functor, Arity),
+    ( length(ArgList, Len), Len \= Arity -> err(Len) ; true ),
+    GInstantiated =.. [Functor|ArgList],
+    z(GInstantiated, Numerator),
+    z(G, Denominator),
+    Result is Numerator / Denominator.
+
+z(G, Weight) :-
+    ...

commit 8b68000d408e1ed911f380d02338ca43269cc07a
Author: mxs <mxs@dismail.de>
Date:   Fri Sep 8 22:18:48 2023 +0200

    remove example file

diff --git a/src/stupidgame.pl b/src/stupidgame.pl
deleted file mode 100644
index 0eeb6e9..0000000
--- a/src/stupidgame.pl
+++ /dev/null
@@ -1,21 +0,0 @@
-play(State) :- stop(State,State).
-play(State) :-
-    pay_entrance(State,State1),
-    dice_reward(State1,State2),
-    play(State2).
-
-stop([Player,Banker],_) :-
-    Player1 is Player,
-    Banker1 is Banker,
-    write('Player = '), write(Player1),
-    write('Banker = '), write(Banker1).
-pay_entrance([Player,Banker],[Player-4,Banker+4]).
-dice_reward([Player,Banker],[Player+D,Banker-D]) :- roll_dice(D).
-
-1/6::roll_dice(1).
-1/6::roll_dice(1).
-1/6::roll_dice(2).
-1/6::roll_dice(3).
-1/6::roll_dice(4).
-1/6::roll_dice(5).
-1/6::roll_dice(6).

commit 000224fe9b552c00055a7b14296d0bde687739e3
Author: mxs <mxs@dismail.de>
Date:   Fri Sep 8 19:23:06 2023 +0200

    add a trace

diff --git a/src/debug/broken-inference.log b/src/debug/broken-inference.log
new file mode 100644
index 0000000..9666c23
--- /dev/null
+++ b/src/debug/broken-inference.log
@@ -0,0 +1,115 @@
+[trace]  ?- inference_(z(X), P).
+   Call: (10) inference_(z(_14324), _14330) ? creep
+   Call: (11) collect_clauses(z(_14324), true, _14330) ? creep
+^  Call: (12) findall((_16480::z(_14324)), clause((_16480::z(_14324)), true), _16496) ? creep
+^  Exit: (12) findall((_16480::z(_14324)), user:clause((_16480::z(_14324)), true), [(0.1::z(a)), (0.9::z(b))]) ? creep
+^  Call: (12) solution_sequences:group_by(z(_14324), _16480, member((_16480::z(_14324)), [(0.1::z(a)), (0.9::z(b))]), _18240) ? creep
+   Call: (13) solution_sequences:ordered_term_variables(user:member((_16480::z(_14324)), [(0.1::z(a)), (0.9::z(b))]), _20544) ? creep
+   Call: (14) term_variables(user:member((_16480::z(_14324)), [(0.1::z(a)), (0.9::z(b))]), _21368) ? creep
+   Exit: (14) term_variables(user:member((_16480::z(_14324)), [(0.1::z(a)), (0.9::z(b))]), [_16480, _14324]) ? creep
+   Call: (14) sort([_16480, _14324], _20544) ? creep
+   Exit: (14) sort([_16480, _14324], [_14324, _16480]) ? creep
+   Exit: (13) solution_sequences:ordered_term_variables(user:member((_16480::z(_14324)), [(0.1::z(a)), (0.9::z(b))]), [_14324, _16480]) ? creep
+   Call: (13) solution_sequences:ordered_term_variables(z(_14324)+_16480, _25462) ? creep
+   Call: (14) term_variables(z(_14324)+_16480, _26286) ? creep
+   Exit: (14) term_variables(z(_14324)+_16480, [_14324, _16480]) ? creep
+   Call: (14) sort([_14324, _16480], _25462) ? creep
+   Exit: (14) sort([_14324, _16480], [_14324, _16480]) ? creep
+   Exit: (13) solution_sequences:ordered_term_variables(z(_14324)+_16480, [_14324, _16480]) ? creep
+   Call: (13) ordsets:ord_subtract([_18, _94], [_18, _94], _192) ? creep
+   Exit: (13) ordsets:ord_subtract([_18, _94], [_18, _94], []) ? creep
+^  Call: (13) bagof(_94, []^(user:member((_94::z(_18)), [(0.1::z(a)), (0.9::z(b))])), _154) ? creep
+^  Exit: (13) bagof(_94, solution_sequences:[]^(user:member((_94::z(a)), [(0.1::z(a)), (0.9::z(b))])), [0.1]) ? creep
+^  Exit: (12) solution_sequences:group_by(z(a), _94, user:member((_94::z(a)), [(0.1::z(a)), (0.9::z(b))]), [0.1]) ? creep
+   Call: (12) lists:sum_list([0.1], _20) ? creep
+   Exit: (12) lists:sum_list([0.1], 0.1) ? creep
+   Exit: (11) collect_clauses(z(a), true, 0.1) ? creep
+   Exit: (10) inference_(z(a), 0.1) ? creep
+X = a,
+P = 0.1 ;
+^  Redo: (13) bagof(_94, solution_sequences:[]^(user:member((_94::z(_18)), [(0.1::z(a)), (0.9::z(b))])), _154) ? creep
+^  Exit: (13) bagof(_94, solution_sequences:[]^(user:member((_94::z(b)), [(0.1::z(a)), (0.9::z(b))])), [0.9]) ? creep
+^  Exit: (12) solution_sequences:group_by(z(b), _94, user:member((_94::z(b)), [(0.1::z(a)), (0.9::z(b))]), [0.9]) ? creep
+   Call: (12) lists:sum_list([0.9], _20) ? creep
+   Exit: (12) lists:sum_list([0.9], 0.9) ? creep
+   Exit: (11) collect_clauses(z(b), true, 0.9) ? creep
+   Exit: (10) inference_(z(b), 0.9) ? creep
+X = b,
+P = 0.9 ;
+   Redo: (10) inference_(z(_18), _20) ? creep
+   Call: (11) collect_clauses(z(_18), _25828, _25830) ? creep
+^  Call: (12) findall((_26648::z(_18)), clause((_26648::z(_18)), _25828), _26664) ? creep
+^  Exit: (12) findall((_26648::z(_18)), user:clause((_26648::z(_18)), _25828), [(0.1::z(a)), (0.9::z(b))]) ? creep
+^  Call: (12) solution_sequences:group_by(z(_18), _26648, member((_26648::z(_18)), [(0.1::z(a)), (0.9::z(b))]), _28408) ? creep
+   Call: (13) solution_sequences:ordered_term_variables(user:member((_26648::z(_18)), [(0.1::z(a)), (0.9::z(b))]), _29252) ? creep
+   Call: (14) term_variables(user:member((_26648::z(_18)), [(0.1::z(a)), (0.9::z(b))]), _30076) ? creep
+   Exit: (14) term_variables(user:member((_26648::z(_18)), [(0.1::z(a)), (0.9::z(b))]), [_26648, _18]) ? creep
+   Call: (14) sort([_26648, _18], _29252) ? creep
+   Exit: (14) sort([_26648, _18], [_18, _26648]) ? creep
+   Exit: (13) solution_sequences:ordered_term_variables(user:member((_26648::z(_18)), [(0.1::z(a)), (0.9::z(b))]), [_18, _26648]) ? creep
+   Call: (13) solution_sequences:ordered_term_variables(z(_18)+_26648, _34170) ? creep
+   Call: (14) term_variables(z(_18)+_26648, _34994) ? creep
+   Exit: (14) term_variables(z(_18)+_26648, [_18, _26648]) ? creep
+   Call: (14) sort([_18, _26648], _34170) ? creep
+   Exit: (14) sort([_18, _26648], [_18, _26648]) ? creep
+   Exit: (13) solution_sequences:ordered_term_variables(z(_18)+_26648, [_18, _26648]) ? creep
+   Call: (13) ordsets:ord_subtract([_18, _26648], [_18, _26648], _39082) ? creep
+   Exit: (13) ordsets:ord_subtract([_18, _26648], [_18, _26648], []) ? creep
+^  Call: (13) bagof(_26648, []^(user:member((_26648::z(_18)), [(0.1::z(a)), (0.9::z(b))])), _28408) ? creep
+^  Exit: (13) bagof(_26648, solution_sequences:[]^(user:member((_26648::z(a)), [(0.1::z(a)), (0.9::z(b))])), [0.1]) ? creep
+^  Exit: (12) solution_sequences:group_by(z(a), _26648, user:member((_26648::z(a)), [(0.1::z(a)), (0.9::z(b))]), [0.1]) ? creep
+   Call: (12) lists:sum_list([0.1], _25830) ? creep
+   Exit: (12) lists:sum_list([0.1], 0.1) ? creep
+   Exit: (11) collect_clauses(z(a), _25828, 0.1) ? creep
+   Call: (11) _25828=(_45864, _45866) ? creep
+   Exit: (11) (_45864, _45866)=(_45864, _45866) ? creep
+   Call: (11) inference_(_45864, _47488) ? creep
+   Exit: (11) inference_(true, 1) ? creep
+   Call: (11) inference_(_45866, _49110) ? creep
+   Exit: (11) inference_(true, 1) ? creep
+   Call: (11) _20 is 0.1*1*1 ? creep
+   Exit: (11) 0.1 is 0.1*1*1 ? creep
+   Exit: (10) inference_(z(a), 0.1) ? creep
+X = a,
+P = 0.1 ;
+   Redo: (11) inference_(_45866, _49110) ? creep
+   Call: (12) collect_clauses(_45866, true, _49110) ? creep
+^  Call: (13) findall((_56716::_45866), clause((_56716::_45866), true), _56732) ? creep
+^  Exit: (13) findall((_56716::_45866), user:clause((_56716::_45866), true), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(a)), (0.9::r(b)), (0.0::p(a)), (0.1::p(...)), (... :: ...)|...]) ? creep
+^  Call: (13) solution_sequences:group_by(_45866, _56716, member((_56716::_45866), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(a)), (0.9::r(...)), (... :: ...)|...]), _59204) ? creep
+   Call: (14) solution_sequences:ordered_term_variables(user:member((_56716::_45866), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(...)), (... :: ...)|...]), _60048) ? creep
+   Call: (15) term_variables(user:member((_56716::_45866), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(a)), (0.9::r(...)), (... :: ...)|...]), _60872) ? creep
+   Exit: (15) term_variables(user:member((_56716::_45866), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(a)), (0.9::r(...)), (... :: ...)|...]), [_56716, _45866]) ? creep
+   Call: (15) sort([_56716, _45866], _60048) ? creep
+   Exit: (15) sort([_56716, _45866], [_45866, _56716]) ? creep
+   Exit: (14) solution_sequences:ordered_term_variables(user:member((_56716::_45866), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(...)), (... :: ...)|...]), [_45866, _56716]) ? creep
+   Call: (14) solution_sequences:ordered_term_variables(_45866+_56716, _64966) ? creep
+   Call: (15) term_variables(_45866+_56716, _65790) ? creep
+   Exit: (15) term_variables(_45866+_56716, [_45866, _56716]) ? creep
+   Call: (15) sort([_45866, _56716], _64966) ? creep
+   Exit: (15) sort([_45866, _56716], [_45866, _56716]) ? creep
+   Exit: (14) solution_sequences:ordered_term_variables(_45866+_56716, [_45866, _56716]) ? creep
+   Call: (14) ordsets:ord_subtract([_45866, _56716], [_45866, _56716], _69878) ? creep
+   Exit: (14) ordsets:ord_subtract([_45866, _56716], [_45866, _56716], []) ? creep
+^  Call: (14) bagof(_56716, []^(user:member((_56716::_45866), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(...)), (... :: ...)|...])), _59204) ? creep
+^  Exit: (14) bagof(_56716, solution_sequences:[]^(user:member((_56716::fact), [(0.2::q(a)), (0.1::q(b)), (0.4::q(...)), (... :: ...)|...])), [1/2]) ? creep
+^  Exit: (13) solution_sequences:group_by(fact, _56716, user:member((_56716::fact), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(...)), (... :: ...)|...]), [1/2]) ? creep
+   Call: (13) lists:sum_list([1/2], _49110) ? creep
+   Exit: (13) lists:sum_list([1/2], 0.5) ? creep
+   Exit: (12) collect_clauses(fact, true, 0.5) ? creep
+   Exit: (11) inference_(fact, 0.5) ? creep
+   Call: (11) _20 is 0.1*1*0.5 ? creep
+   Exit: (11) 0.05 is 0.1*1*0.5 ? creep
+   Exit: (10) inference_(z(a), 0.05) ? creep
+X = a,
+P = 0.05 ;
+^  Redo: (14) bagof(_56716, solution_sequences:[]^(user:member((_56716::_45866), [(0.2::q(a)), (0.1::q(b)), (0.4::q(...)), (... :: ...)|...])), _59204) ? creep
+^  Exit: (14) bagof(_56716, solution_sequences:[]^(user:member((_56716::fact1), [(0.2::q(a)), (0.1::q(b)), (0.4::q(...)), (... :: ...)|...])), [1]) ? creep
+^  Exit: (13) solution_sequences:group_by(fact1, _56716, user:member((_56716::fact1), [(0.2::q(a)), (0.1::q(b)), (0.4::q(c)), (0.3::r(...)), (... :: ...)|...]), [1]) ? creep
+   Call: (13) lists:sum_list([1], _49110) ? creep
+   Exit: (13) lists:sum_list([1], 1) ? creep
+   Exit: (12) collect_clauses(fact1, true, 1) ? creep
+   Exit: (11) inference_(fact1, 1) ? creep
+   Call: (11) _20 is 0.1*1*1 ? creep
+   Exit: (11) 0.1 is 0.1*1*1 ? creep
+   Exit: (10) inference_(z(a), 0.1) ?

commit 16b0c52ab289617c9bfa59b65a5824c02cbde797
Author: mxs <mxs@dismail.de>
Date:   Fri Sep 8 19:21:33 2023 +0200

    wip: fixing inference in SLP interpretation

diff --git a/src/metainterp.pl b/src/metainterp.pl
index 59a43f8..b6bcd49 100644
--- a/src/metainterp.pl
+++ b/src/metainterp.pl
@@ -1,50 +1,62 @@
 :- op(1199,xfx,::).
+:- discontiguous (::)/2.
+
+% SLP interpretation, collecting multiple clauses
+inference(Rule, ProbLists_summed) :-
+    findall(Prob::Rule, inference_(Rule, Prob), ProbList),
+    group_by(Rule, Prob, member(Prob::Rule, ProbList), ProbLists),
+    sum_list(ProbLists, ProbLists_summed).
+
+collect_clauses(Rule, Body, PRet) :-
+    findall(Prob::Rule, clause((Prob :: Rule), Body), ClauseList),
+    group_by(Rule, Prob, member(Prob::Rule, ClauseList), ProbLists),
+    sum_list(ProbLists, PRet).
 
 % case 'Rule = true'
-% only with inference(true, Prob)
-inference(true, 1).
+% only with inference_(true, Prob)
+inference_(true, 1).
 
 % body of Rule === true, happens when Rule is atomic
 % (e.g. 0.7 :: q(a), so when asking for a fact -
 % in this case clause automatically sets the body to true)
 % or as a base case of both recursions
-inference(Rule, Prob) :-
+inference_(Rule, Prob) :-
     % clause: find a head and its corresponding body and unify
-    clause(Prob :: Rule, true).
+    collect_clauses(Rule, true, Prob).
 
 % head recursion
-inference((Goal1, Goal2), ProbRes) :-
-    inference(Goal1, Prob1),
-    inference(Goal2, Prob2),
+inference_((Goal1, Goal2), ProbRes) :-
+    inference_(Goal1, Prob1),
+    inference_(Goal2, Prob2),
     ProbRes is Prob1*Prob2.
 
 % head recursion
-inference((Goal1; Goal2), ProbRes) :-
-    inference(Goal1, Prob1),
-    inference(Goal2, Prob2),
+inference_((Goal1; Goal2), ProbRes) :-
+    inference_(Goal1, Prob1),
+    inference_(Goal2, Prob2),
     ProbRes is (Prob1 + Prob2  - Prob1*Prob2).
 
 % body recursion, compound
-inference(Rule, ProbRes) :-
+inference_(Rule, ProbRes) :-
     % body is not yet bound, we bind it here
-    clause((PRet :: Rule), Body),
+    collect_clauses(Rule, Body, PRet),
     Body = (Goal1, Goal2), 
-    inference(Goal1, Prob1),
-    inference(Goal2, Prob2),
+    inference_(Goal1, Prob1),
+    inference_(Goal2, Prob2),
     ProbRes is PRet*Prob1*Prob2.
 
 % body recursion, compound
-inference(Rule, ProbRes) :-
-    clause((PRet :: Rule), Body),
+inference_(Rule, ProbRes) :-
+    collect_clauses(Rule, Body, PRet),
     Body = (Goal1; Goal2), 
-    inference(Goal1, Prob1),
-    inference(Goal2, Prob2),
+    inference_(Goal1, Prob1),
+    inference_(Goal2, Prob2),
     % this recursion exactly corresponds to the inclusion-exclusion-principle
     ProbRes is PRet*(Prob1 + Prob2 - Prob1*Prob2).
 
 % body recursion, non-compound
-inference(Rule, ProbRes) :-
-    clause((PRet :: Rule), Body),
+inference_(Rule, ProbRes) :-
+    collect_clauses(Rule, Body, PRet),
 
     % preventing above cases to fire again
     Body \= (Goal1, Goal2),
@@ -52,7 +64,7 @@ inference(Rule, ProbRes) :-
     Body \= true,
 
     % now our body is the new goal
-    inference(Body, Prob),
+    inference_(Body, Prob),
     ProbRes is PRet*Prob.
 
 sampling(Head) :-
@@ -82,12 +94,11 @@ transform_probabilities([P1::B1,P2::B2|B], L) :-
 % TESTS
 
 % seem to be all ok
-0.5::roll_dice(2).
 
 0.5::s(X) :- z(X).
 
+% want(a): 0.4*(0.2+0.3*1 + 0.3 - (0.2+0.3*1)*0.3) + 0.2* (0.2+0.3*1)*1.2 = 0.38
 0.4::t(X) :- q(X); r(X).
-
 0.2::t(X) :- q(X), r(Y).
 
 0.7 :: u(X) :- q(X), r(X), p(X).
@@ -97,8 +108,9 @@ transform_probabilities([P1::B1,P2::B2|B], L) :-
 % inference(q(X), Prob).
 % ===> zeige die Whrschktn für alle Belegungen an
 0.2 :: q(a).
+0.3 :: q(a) :- fact1.
 0.1 :: q(b).
-0.7 :: q(c).
+0.4 :: q(c).
 
 0.3 :: r(a).
 0.9 :: r(b).
@@ -115,9 +127,108 @@ transform_probabilities([P1::B1,P2::B2|B], L) :-
 0.1 :: z(a).
 0.9 :: z(b).
 
+% test: stupidgame
+play(State) :- stop(State,State).
+play(State) :-
+    pay_entrance(State,State1),
+    dice_reward(State1,State2),
+    play(State2).
+
+stop([Player,Banker],_) :-
+    Player1 is Player,
+    Banker1 is Banker,
+    write('Player = '), write(Player1),
+    write('Banker = '), write(Banker1).
+pay_entrance([Player,Banker],[Player-4,Banker+4]).
+dice_reward([Player,Banker],[Player+D,Banker-D]) :- roll_dice(D).
+
+1/6::roll_dice(1).
+1/6::roll_dice(2).
+1/6::roll_dice(3).
+1/6::roll_dice(4).
+1/6::roll_dice(5).
+1/6::roll_dice(6).
+
 % TODO/extra:
 % sampling(q(X), q(Z)) -> sampling(q(X)), sampling(q(Z)).
 % sampling(q(X), p(Z)) -> sampling(q(X)), sampling(p(Z))
 % sampling(q(X), p(X)) -> assert(1 :: neu(X) :- q(X), p(X).), sampling(neu(X)), retract(neu).
 % sampling(q(X), q(X)) -> sampling(q(X))
 
+% q === rot
+% p === König
+% sampling(q(X), p(Z))
+% P(X rot , Z ist ein König) = (1/4)*(1/13) = 1/52 = 13*4 / 52^2
+
+% q === rot
+% p === König
+% sampling(q(X), p(X))
+% P(X ist rot und ein König) = 1/52
+
+% q === rot
+% sampling(q(X), q(Z))
+% P(X ist rot und Z ist rot) = 1/16
+
+% q === rot
+% sampling(q(X), q(X))
+% P(X ist rot und X ist rot) = 1/4 * 1
+
+1/4::karte(karo).
+1/4::karte(herz).
+1/4::karte(pik).
+1/4::karte(kreuz).
+
+1/4::herz(karte).
+1/4::karo(karte).
+1/4::pik(karte).
+1/4::kreuz(karte).
+1/13::koenig(karte).
+
+% slp / plp?
+% want: P === 1
+1/2::goal :- fact1.
+1/2::goal :- fact2.
+1::fact1.
+1::fact2.
+
+% slp no sharing of subgoals between branches
+% want: P === 0.25
+1::goal1 :- left, right.
+1::left :- fact.
+1::right :- fact.
+1/2::fact :- true.
+1/2::fact :- fail.
+
+% slp, nested subgoals
+% want: P === 0.5^2* (0.25+3/8)  + 0.5 = 0.65625
+0.5::goal2 :- left1, right1.
+0.5::goal2 :- true.
+3/4::left1 :- newfact.
+1/4::left1 :- true.
+1::right1 :- newfact.
+1/2::newfact :- true.
+1/2::newfact :- fail.
+
+% slp, nested subgoals 2
+% want: P === 1/2 + (1/3 + 1/3*(3/5+(1/5*2/5))*(2/5)) = 0.9240
+1/2 :: gl0 :- true.
+1/2 :: gl0 :- gl1.
+
+1/3 :: gl1 :- true.
+1/3 :: gl1 :- fail.
+1/3 :: gl1 :- gl21, gl22.
+
+1/5 :: gl21 :- true.
+1/5 :: gl21 :- true.
+1/5 :: gl21 :- true.
+1/5 :: gl21 :- gl22.
+1/5 :: gl21 :- fail.
+
+1/5 :: gl22 :- true.
+1/5 :: gl22 :- true.
+1/5 :: gl22 :- fail.
+1/5 :: gl22 :- fail.
+1/5 :: gl22 :- fail.
+
+
+

commit 111a545696c5995e30182e772ab29f7e94854060
Author: mxs <mxs@dismail.de>
Date:   Thu Sep 7 19:15:11 2023 +0200

    remove editor swap file

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..2d96ba3
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1 @@
+*.kate-swp
diff --git a/src/.sampling.pl.kate-swp b/src/.sampling.pl.kate-swp
deleted file mode 100644
index c37bc68..0000000
Binary files a/src/.sampling.pl.kate-swp and /dev/null differ

commit 5d92cdcf87aac46535e2508904f132b388f976e8
Author: mxs <mxs@dismail.de>
Date:   Thu Sep 7 19:12:20 2023 +0200

    sampling + inference

diff --git a/src/metainterp.pl b/src/metainterp.pl
index a6e5bc6..59a43f8 100644
--- a/src/metainterp.pl
+++ b/src/metainterp.pl
@@ -1,6 +1,6 @@
 :- op(1199,xfx,::).
 
-% base case 'Rule = true'
+% case 'Rule = true'
 % only with inference(true, Prob)
 inference(true, 1).
 
@@ -55,12 +55,36 @@ inference(Rule, ProbRes) :-
     inference(Body, Prob),
     ProbRes is PRet*Prob.
 
-
+sampling(Head) :-
+    % need to compute the actual probabilities for all probability-head pairs
+    findall(Prob::Head, inference(Head, Prob), ProbHeadPairs),
+    transform_probabilities(ProbHeadPairs, ShiftedProbHeadPairs),
+    last(ShiftedProbHeadPairs, UpperUniformEnd :: _),
+    % we just sample once for now
+    !,
+    SampleProb is random_float * UpperUniformEnd,
+    select_head(ShiftedProbHeadPairs, SampleProb, Head).
+
+select_head([], _, false).
+select_head([ShiftedProb::ShiftedHead|Tail], SampleProb, Sample) :-
+    ( ShiftedProb >= SampleProb
+    -> Sample = ShiftedHead
+    ; select_head(Tail, SampleProb, Sample)).
+
+% shift the probabilities recursively so we can sample from a uniform distribution
+transform_probabilities([], []).
+transform_probabilities([P::B], [P::B]).
+transform_probabilities([P1::B1,P2::B2|B], L) :-
+    TransfromedProb is P1 + P2,
+    transform_probabilities([TransfromedProb::B2|B], TempL),
+    L = [P1::B1|TempL].
+
+% TESTS
 
 % seem to be all ok
 0.5::roll_dice(2).
 
-0.5::s(X) :- q(X).
+0.5::s(X) :- z(X).
 
 0.4::t(X) :- q(X); r(X).
 
@@ -79,16 +103,21 @@ inference(Rule, ProbRes) :-
 0.3 :: r(a).
 0.9 :: r(b).
 
+% maybe these should add up to 1 after all to make sense (but our sampling works regardless)
 0.0 :: p(a).
 0.1 :: p(b).
 0.9 :: p(c).
 
 0.5 :: d(X, Y) :- p(X), q(Y).
 
-% want:
-% inference((d(X, Y), u(X)), Prob).
-% inference((d(X, Y); u(X)), Prob).
-% strategy: assert(1 :: neu(X, Y) :- d(X, Y), u(X) bzw ; u(X)), sampling(neu(...)), retract(neu).
-
+% sampling(z(X)) ===> eher b
+% random testing: a: 5x, b: 72x
+0.1 :: z(a).
+0.9 :: z(b).
 
+% TODO/extra:
+% sampling(q(X), q(Z)) -> sampling(q(X)), sampling(q(Z)).
+% sampling(q(X), p(Z)) -> sampling(q(X)), sampling(p(Z))
+% sampling(q(X), p(X)) -> assert(1 :: neu(X) :- q(X), p(X).), sampling(neu(X)), retract(neu).
+% sampling(q(X), q(X)) -> sampling(q(X))
 

commit 1137486e384e5502b86d8489594e898572fe13b0
Author: mxs <mxs@dismail.de>
Date:   Thu Sep 7 17:50:57 2023 +0200

    sampling + inference works

diff --git a/src/inference.pl b/src/metainterp.pl
similarity index 100%
rename from src/inference.pl
rename to src/metainterp.pl
diff --git a/src/sampling.pl b/src/sampling.pl
deleted file mode 100644
index d65e2e5..0000000
--- a/src/sampling.pl
+++ /dev/null
@@ -1,35 +0,0 @@
-:- op(600, xfx, ::).
-
-% TODO: base case
-sampling(Head) :-
-    % get all probability-head pairs
-    Head =.. [Functor|ArgsL],
-    findall(Prob::Head, Prob::Head, ProbHeadPairs),
-    transform_probabilities(ProbHeadPairs, ShiftedProbHeadPairs),
-    last(ShiftedProbHeadPairs, UpperUniformEnd :: _),
-    % we just sample once for now
-    !,
-    SampleProb is random_float * UpperUniformEnd,
-    select_head(ShiftedProbHeadPairs, SampleProb, Head).
-
-select_head([], _, false).
-select_head([ShiftedProb::ShiftedHead|Tail], SampleProb, Sample) :-
-    ( ShiftedProb >= SampleProb
-    -> Sample = ShiftedHead
-    ; select_head(Tail, SampleProb, Sample)).
-
-% shift the probabilities recursively so we can sample from a uniform distribution
-transform_probabilities([], []).
-transform_probabilities([P::B], [P::B]).
-transform_probabilities([P1::B1,P2::B2|B], L) :-
-    TransfromedProb is P1 + P2,
-    transform_probabilities([TransfromedProb::B2|B], TempL),
-    L = [P1::B1|TempL].
-
-% sampling(q(X)) ===> eher b
-% random testing: a: 5x, b: 72x
-
-0.1 :: q(a).
-0.9 :: q(b).
-0.3 :: p(x).
-

commit 1e0b9f8899cee11a89a6f8c836afea902c40d3b8
Author: mxs <mxs@dismail.de>
Date:   Thu Sep 7 17:19:51 2023 +0200

    refactor inference

diff --git a/src/metaintep.pl b/src/inference.pl
similarity index 66%
rename from src/metaintep.pl
rename to src/inference.pl
index 6ec3e21..a6e5bc6 100644
--- a/src/metaintep.pl
+++ b/src/inference.pl
@@ -1,23 +1,30 @@
 :- op(1199,xfx,::).
 
 % base case 'Rule = true'
-inference(true, 1) :- !.
+% only with inference(true, Prob)
+inference(true, 1).
 
-% base case 'body of Rule = true', i.e. Rule atomic and in particular not compound
+% body of Rule === true, happens when Rule is atomic
+% (e.g. 0.7 :: q(a), so when asking for a fact -
+% in this case clause automatically sets the body to true)
+% or as a base case of both recursions
 inference(Rule, Prob) :-
+    % clause: find a head and its corresponding body and unify
     clause(Prob :: Rule, true).
 
+% head recursion
 inference((Goal1, Goal2), ProbRes) :-
     inference(Goal1, Prob1),
     inference(Goal2, Prob2),
-    ProbRes is Prob1*Prob2, !.
+    ProbRes is Prob1*Prob2.
 
+% head recursion
 inference((Goal1; Goal2), ProbRes) :-
     inference(Goal1, Prob1),
     inference(Goal2, Prob2),
-    ProbRes is (Prob1 + Prob2  - Prob1*Prob2), !.
+    ProbRes is (Prob1 + Prob2  - Prob1*Prob2).
 
-% case 'compound body, conjunction'
+% body recursion, compound
 inference(Rule, ProbRes) :-
     % body is not yet bound, we bind it here
     clause((PRet :: Rule), Body),
@@ -26,27 +33,27 @@ inference(Rule, ProbRes) :-
     inference(Goal2, Prob2),
     ProbRes is PRet*Prob1*Prob2.
 
-% case 'compound body, disjunction'
+% body recursion, compound
 inference(Rule, ProbRes) :-
     clause((PRet :: Rule), Body),
     Body = (Goal1; Goal2), 
     inference(Goal1, Prob1),
     inference(Goal2, Prob2),
-    % this recursion exactly corresponds to the inclusion-exclusion-principle!
+    % this recursion exactly corresponds to the inclusion-exclusion-principle
     ProbRes is PRet*(Prob1 + Prob2 - Prob1*Prob2).
 
-% case 'single predicate body'
+% body recursion, non-compound
 inference(Rule, ProbRes) :-
     clause((PRet :: Rule), Body),
-    ( Body = true
-    -> fail, !
-    % preventing compound case from unifying with this more general case
-    ; Body \= (Goal1, Goal2),
-        % preventing compound case from unifying with this more general case
-        Body \= (Goal1; Goal2),
-        Body = Goal,
-        inference(Goal, Prob),
-        ProbRes is PRet*Prob).
+
+    % preventing above cases to fire again
+    Body \= (Goal1, Goal2),
+    Body \= (Goal1; Goal2),
+    Body \= true,
+
+    % now our body is the new goal
+    inference(Body, Prob),
+    ProbRes is PRet*Prob.
 
 
 

commit 4b97b3efcd8ff4258f1f2a61fb63325bab2d6956
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Thu Sep 7 16:36:33 2023 +0200

    reformatting inference function: deleting rule_rec and incorporating it in inference as first two rules

diff --git a/src/metaintep.pl b/src/metaintep.pl
index ec5000d..6ec3e21 100644
--- a/src/metaintep.pl
+++ b/src/metaintep.pl
@@ -7,57 +7,48 @@ inference(true, 1) :- !.
 inference(Rule, Prob) :-
     clause(Prob :: Rule, true).
 
+inference((Goal1, Goal2), ProbRes) :-
+    inference(Goal1, Prob1),
+    inference(Goal2, Prob2),
+    ProbRes is Prob1*Prob2, !.
+
+inference((Goal1; Goal2), ProbRes) :-
+    inference(Goal1, Prob1),
+    inference(Goal2, Prob2),
+    ProbRes is (Prob1 + Prob2  - Prob1*Prob2), !.
+
 % case 'compound body, conjunction'
 inference(Rule, ProbRes) :-
-    % check: Rule not compound
-    ( Rule \= (Goal1, Goal2), Rule \= (Goal1; Goal2)
     % body is not yet bound, we bind it here
-    -> clause((PRet :: Rule), Body),
-        Body = (Goal1, Goal2), 
-        inference(Goal1, Prob1),
-        inference(Goal2, Prob2),
-        ProbRes is PRet*Prob1*Prob2
-    % cut guarantees single rule_rec call for current Rule; otherwise called again in following cases
-    ; rule_rec(Rule, ProbRes), !).
+    clause((PRet :: Rule), Body),
+    Body = (Goal1, Goal2), 
+    inference(Goal1, Prob1),
+    inference(Goal2, Prob2),
+    ProbRes is PRet*Prob1*Prob2.
 
 % case 'compound body, disjunction'
 inference(Rule, ProbRes) :-
-    % check: Rule not compound
-    ( Rule \= (Goal1, Goal2), Rule \= (Goal1; Goal2)
-    -> clause((PRet :: Rule), Body),
-        Body = (Goal1; Goal2), 
-        inference(Goal1, Prob1),
-        inference(Goal2, Prob2),
-        % this recursion exactly corresponds to the inclusion-exclusion-principle!
-        ProbRes is PRet*(Prob1 + Prob2 - Prob1*Prob2)
-    ; rule_rec(Rule, ProbRes), !).
+    clause((PRet :: Rule), Body),
+    Body = (Goal1; Goal2), 
+    inference(Goal1, Prob1),
+    inference(Goal2, Prob2),
+    % this recursion exactly corresponds to the inclusion-exclusion-principle!
+    ProbRes is PRet*(Prob1 + Prob2 - Prob1*Prob2).
 
 % case 'single predicate body'
 inference(Rule, ProbRes) :-
-    % check: Rule not compound
-    ( Rule \= (Goal1, Goal2), Rule \= (Goal1; Goal2)
-    -> clause((PRet :: Rule), Body),
-        ( Body = true
-        -> fail, !
+    clause((PRet :: Rule), Body),
+    ( Body = true
+    -> fail, !
+    % preventing compound case from unifying with this more general case
+    ; Body \= (Goal1, Goal2),
         % preventing compound case from unifying with this more general case
-        ; Body \= (Goal1, Goal2),
-            % preventing compound case from unifying with this more general case
-            Body \= (Goal1; Goal2),
-            Body = Goal,
-            inference(Goal, Prob),
-            ProbRes is PRet*Prob)
-    % cut guarantees single rule_rec call for current Rule; perhaps not necessary, but symmetric to above cases
-    ; rule_rec(Rule, ProbRes), !).
-
-rule_rec((Goal1, Goal2), ProbRes) :-
-    inference(Goal1, Prob1),
-    inference(Goal2, Prob2),
-    ProbRes is Prob1*Prob2.
+        Body \= (Goal1; Goal2),
+        Body = Goal,
+        inference(Goal, Prob),
+        ProbRes is PRet*Prob).
+
 
-rule_rec((Goal1; Goal2), ProbRes) :-
-    inference(Goal1, Prob1),
-    inference(Goal2, Prob2),
-    ProbRes is (Prob1 + Prob2  - Prob1*Prob2).
 
 % seem to be all ok
 0.5::roll_dice(2).

commit 2f398242d3ca584fd5ffa2fef932a0817de2ccc5
Author: mxs <mxs@dismail.de>
Date:   Thu Sep 7 16:14:38 2023 +0200

    add question on task

diff --git a/task.txt b/task.txt
index 246daa0..51b50ee 100644
--- a/task.txt
+++ b/task.txt
@@ -12,6 +12,9 @@ max:
             algorithms: from cussens paper
     * something to aid programmer in meeting requirements
         all clauses add to < 1 für jede mögliche belegung
+            FRAGE: was ist damit gemeint?
+                wir gehen davon aus das alle ereignisse unabhängig aber nicht disjunkt sind.
+                damit berechnet sich die wahscheinlichekit über p1 + p2 - p1*p2 und ist in jeder clause <= 1.
 
 implementation:
 berechnungen können alle in ffi sein (c/c++/rust), core logic in prolog

commit 7bbad62b9820f2cca6e859e992fe58acd369baf0
Author: mxs <mxs@dismail.de>
Date:   Thu Sep 7 16:14:12 2023 +0200

    start next task (multivar inference)

diff --git a/src/.sampling.pl.kate-swp b/src/.sampling.pl.kate-swp
new file mode 100644
index 0000000..c37bc68
Binary files /dev/null and b/src/.sampling.pl.kate-swp differ
diff --git a/src/metaintep.pl b/src/metaintep.pl
index dba04ec..ec5000d 100644
--- a/src/metaintep.pl
+++ b/src/metaintep.pl
@@ -11,6 +11,7 @@ inference(Rule, Prob) :-
 inference(Rule, ProbRes) :-
     % check: Rule not compound
     ( Rule \= (Goal1, Goal2), Rule \= (Goal1; Goal2)
+    % body is not yet bound, we bind it here
     -> clause((PRet :: Rule), Body),
         Body = (Goal1, Goal2), 
         inference(Goal1, Prob1),
@@ -70,6 +71,9 @@ rule_rec((Goal1; Goal2), ProbRes) :-
 0.7 :: u(X) :- q(X), r(X), p(X).
 0.3 :: u(X) :- q(X); r(X); p(X).
 
+% API:
+% inference(q(X), Prob).
+% ===> zeige die Whrschktn für alle Belegungen an
 0.2 :: q(a).
 0.1 :: q(b).
 0.7 :: q(c).
@@ -80,3 +84,13 @@ rule_rec((Goal1; Goal2), ProbRes) :-
 0.0 :: p(a).
 0.1 :: p(b).
 0.9 :: p(c).
+
+0.5 :: d(X, Y) :- p(X), q(Y).
+
+% want:
+% inference((d(X, Y), u(X)), Prob).
+% inference((d(X, Y); u(X)), Prob).
+% strategy: assert(1 :: neu(X, Y) :- d(X, Y), u(X) bzw ; u(X)), sampling(neu(...)), retract(neu).
+
+
+

commit ccdd4b50605acf21c886676aab20388cf9898b56
Author: mxs <mxs@dismail.de>
Date:   Mon Sep 4 15:03:09 2023 +0200

    inference: comments

diff --git a/src/metaintep.pl b/src/metaintep.pl
index ff58768..dba04ec 100644
--- a/src/metaintep.pl
+++ b/src/metaintep.pl
@@ -1,41 +1,52 @@
-% lesen von probabilities
 :- op(1199,xfx,::).
 
-inference(true, 1) :- !. % base case 'Rule = true'
+% base case 'Rule = true'
+inference(true, 1) :- !.
 
-inference(Rule, Prob) :- % base case 'body of Rule = true', i.e. Rule atomic and in particular not compound
+% base case 'body of Rule = true', i.e. Rule atomic and in particular not compound
+inference(Rule, Prob) :-
     clause(Prob :: Rule, true).
 
-inference(Rule, ProbRes) :- % case 'compound body, conjunction'
-    ( Rule \= (Goal1, Goal2), Rule \= (Goal1; Goal2) % check: Rule not compound
+% case 'compound body, conjunction'
+inference(Rule, ProbRes) :-
+    % check: Rule not compound
+    ( Rule \= (Goal1, Goal2), Rule \= (Goal1; Goal2)
     -> clause((PRet :: Rule), Body),
         Body = (Goal1, Goal2), 
         inference(Goal1, Prob1),
         inference(Goal2, Prob2),
         ProbRes is PRet*Prob1*Prob2
-    ; rule_rec(Rule, ProbRes), !). % cut guarantees single rule_rec call for current Rule; otherwise called again in following cases
+    % cut guarantees single rule_rec call for current Rule; otherwise called again in following cases
+    ; rule_rec(Rule, ProbRes), !).
 
-inference(Rule, ProbRes) :- % case 'compound body, disjunction'
-    ( Rule \= (Goal1, Goal2), Rule \= (Goal1; Goal2) % check: Rule not compound
+% case 'compound body, disjunction'
+inference(Rule, ProbRes) :-
+    % check: Rule not compound
+    ( Rule \= (Goal1, Goal2), Rule \= (Goal1; Goal2)
     -> clause((PRet :: Rule), Body),
         Body = (Goal1; Goal2), 
         inference(Goal1, Prob1),
         inference(Goal2, Prob2),
         % this recursion exactly corresponds to the inclusion-exclusion-principle!
         ProbRes is PRet*(Prob1 + Prob2 - Prob1*Prob2)
-    ; rule_rec(Rule, ProbRes), !). % cut guarantees single rule_rec call for current Rule; otherwise called again in following case
+    ; rule_rec(Rule, ProbRes), !).
 
-inference(Rule, ProbRes) :- % case 'single predicate body'
-    ( Rule \= (Goal1, Goal2), Rule \= (Goal1; Goal2) % check: Rule not compound
+% case 'single predicate body'
+inference(Rule, ProbRes) :-
+    % check: Rule not compound
+    ( Rule \= (Goal1, Goal2), Rule \= (Goal1; Goal2)
     -> clause((PRet :: Rule), Body),
         ( Body = true
         -> fail, !
-        ; Body \= (Goal1, Goal2), % preventing compound case from unifying with this more general case
-            Body \= (Goal1; Goal2), % preventing compound case from unifying with this more general case
+        % preventing compound case from unifying with this more general case
+        ; Body \= (Goal1, Goal2),
+            % preventing compound case from unifying with this more general case
+            Body \= (Goal1; Goal2),
             Body = Goal,
             inference(Goal, Prob),
             ProbRes is PRet*Prob)
-    ; rule_rec(Rule, ProbRes), !). % cut guarantees single rule_rec call for current Rule; perhaps not necessary, but symmetric to above cases
+    % cut guarantees single rule_rec call for current Rule; perhaps not necessary, but symmetric to above cases
+    ; rule_rec(Rule, ProbRes), !).
 
 rule_rec((Goal1, Goal2), ProbRes) :-
     inference(Goal1, Prob1),
@@ -47,8 +58,6 @@ rule_rec((Goal1; Goal2), ProbRes) :-
     inference(Goal2, Prob2),
     ProbRes is (Prob1 + Prob2  - Prob1*Prob2).
 
-% not yet tested
-
 % seem to be all ok
 0.5::roll_dice(2).
 

commit 0e7692f6dd64e7e5175ecec056b6f9cb4c0e56ce
Author: mxs <mxs@dismail.de>
Date:   Mon Sep 4 15:03:09 2023 +0200

    inference: add some comments

diff --git a/src/metaintep.pl b/src/metaintep.pl
index e68bbe2..ff58768 100644
--- a/src/metaintep.pl
+++ b/src/metaintep.pl
@@ -1,8 +1,3 @@
-% vim: filetype=prolog
-
-
-
-
 % lesen von probabilities
 :- op(1199,xfx,::).
 
@@ -26,6 +21,7 @@ inference(Rule, ProbRes) :- % case 'compound body, disjunction'
         Body = (Goal1; Goal2), 
         inference(Goal1, Prob1),
         inference(Goal2, Prob2),
+        % this recursion exactly corresponds to the inclusion-exclusion-principle!
         ProbRes is PRet*(Prob1 + Prob2 - Prob1*Prob2)
     ; rule_rec(Rule, ProbRes), !). % cut guarantees single rule_rec call for current Rule; otherwise called again in following case
 
@@ -49,7 +45,7 @@ rule_rec((Goal1, Goal2), ProbRes) :-
 rule_rec((Goal1; Goal2), ProbRes) :-
     inference(Goal1, Prob1),
     inference(Goal2, Prob2),
-    ProbRes is (Prob1 + Prob2 - Prob1*Prob2).
+    ProbRes is (Prob1 + Prob2  - Prob1*Prob2).
 
 % not yet tested
 
@@ -65,13 +61,13 @@ rule_rec((Goal1; Goal2), ProbRes) :-
 0.7 :: u(X) :- q(X), r(X), p(X).
 0.3 :: u(X) :- q(X); r(X); p(X).
 
-0.4 :: q(a).
-0.5 :: q(b).
+0.2 :: q(a).
+0.1 :: q(b).
 0.7 :: q(c).
 
 0.3 :: r(a).
-0.7 :: r(b).
+0.9 :: r(b).
 
-0.6 :: p(a).
+0.0 :: p(a).
 0.1 :: p(b).
 0.9 :: p(c).

commit 90c7f139b23f81538759db5098ac2290d590da5b
Author: mxs <mxs@dismail.de>
Date:   Mon Sep 4 15:02:20 2023 +0200

    sampling works!

diff --git a/src/sampling.pl b/src/sampling.pl
index 68eae69..d65e2e5 100644
--- a/src/sampling.pl
+++ b/src/sampling.pl
@@ -1,34 +1,35 @@
-% vim: filetype=prolog
-
-:- op(601, xfx, <--).
 :- op(600, xfx, ::).
 
-sampling([]).
-sampling([LAtom|Atoms]) :-
-    findall(Prob :: Body, Prob :: LAtom <-- Body, TempSubs),
-    transform_probabilities(TempSubs, Subs),
-    last(Subs, ProbWeight),
+% TODO: base case
+sampling(Head) :-
+    % get all probability-head pairs
+    Head =.. [Functor|ArgsL],
+    findall(Prob::Head, Prob::Head, ProbHeadPairs),
+    transform_probabilities(ProbHeadPairs, ShiftedProbHeadPairs),
+    last(ShiftedProbHeadPairs, UpperUniformEnd :: _),
+    % we just sample once for now
     !,
-    % Use clause?
-    bagof(Prob :: Body, Prob :: LAtom <-- Body, SubCandidate),
-
-
-    select_sub(Subs, Rand, 0, Sub),
-    append(Sub,Atoms,NewAtoms),
-    sampling(NewAtoms).
+    SampleProb is random_float * UpperUniformEnd,
+    select_head(ShiftedProbHeadPairs, SampleProb, Head).
 
-select_sub([LProb :: LSub|Subs], Rand, Akk, Sub) :-
-    ChoiceValue is LProb + Akk,
-    (ChoiceValue >= Rand
-        -> Sub = LSub
-        ; select_sub(Subs, Rand, ChoiceValue, Sub)).
+select_head([], _, false).
+select_head([ShiftedProb::ShiftedHead|Tail], SampleProb, Sample) :-
+    ( ShiftedProb >= SampleProb
+    -> Sample = ShiftedHead
+    ; select_head(Tail, SampleProb, Sample)).
 
+% shift the probabilities recursively so we can sample from a uniform distribution
 transform_probabilities([], []).
 transform_probabilities([P::B], [P::B]).
 transform_probabilities([P1::B1,P2::B2|B], L) :-
     TransfromedProb is P1 + P2,
-    transform_probabilities([TransfromedProb:B2|B], TempL),
+    transform_probabilities([TransfromedProb::B2|B], TempL),
     L = [P1::B1|TempL].
 
-0.5 :: q(a) <-- [].
-0.5 :: q(b) <-- [].
+% sampling(q(X)) ===> eher b
+% random testing: a: 5x, b: 72x
+
+0.1 :: q(a).
+0.9 :: q(b).
+0.3 :: p(x).
+

commit 55d4f8c702b7aedc656afe22e7d5878d74af3128
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Fri Aug 11 12:00:44 2023 +0200

    removing cuts to allow backtracking over Body format in some cases - adding \= in single predicate body case instead; extending functionality: probability calculations for multiple events possible

diff --git a/src/metaintep.pl b/src/metaintep.pl
index d3fded9..e68bbe2 100644
--- a/src/metaintep.pl
+++ b/src/metaintep.pl
@@ -6,49 +6,72 @@
 % lesen von probabilities
 :- op(1199,xfx,::).
 
-demo(true, 1) :- !. % base case 'Rule = true'
+inference(true, 1) :- !. % base case 'Rule = true'
 
-demo(Rule, Prob) :- % base case 'body of Rule = true', i.e. Rule atomic
+inference(Rule, Prob) :- % base case 'body of Rule = true', i.e. Rule atomic and in particular not compound
     clause(Prob :: Rule, true).
 
-demo(Rule, ProbRes) :- % case 'compounded body, conjunction'
-    clause((PRet :: Rule), Body),
-    Body = (Goal1, Goal2), 
-    !, % cut prevents unifying with 'single predicate body' case as well
-    demo(Goal1, Prob1),
-    demo(Goal2, Prob2),
-    ProbRes is PRet*Prob1*Prob2.
-
-demo(Rule, ProbRes) :- % case 'compounded body, disjunction'
-    clause((PRet :: Rule), Body),
-    Body = (Goal1; Goal2), 
-    !, % cut prevents unifying with Body = Goal case as well
-    demo(Goal1, Prob1),
-    demo(Goal2, Prob2),
-    ProbRes is PRet*(Prob1 + Prob2 - Prob1*Prob2).
-
-demo(Rule, ProbRes) :- % case 'single predicate body'
-    clause((PRet :: Rule), Body),
-    ( Body = true
-    -> fail, !
-    ; Body = Goal,
-    demo(Goal, Prob),
-    ProbRes is PRet*Prob).
+inference(Rule, ProbRes) :- % case 'compound body, conjunction'
+    ( Rule \= (Goal1, Goal2), Rule \= (Goal1; Goal2) % check: Rule not compound
+    -> clause((PRet :: Rule), Body),
+        Body = (Goal1, Goal2), 
+        inference(Goal1, Prob1),
+        inference(Goal2, Prob2),
+        ProbRes is PRet*Prob1*Prob2
+    ; rule_rec(Rule, ProbRes), !). % cut guarantees single rule_rec call for current Rule; otherwise called again in following cases
+
+inference(Rule, ProbRes) :- % case 'compound body, disjunction'
+    ( Rule \= (Goal1, Goal2), Rule \= (Goal1; Goal2) % check: Rule not compound
+    -> clause((PRet :: Rule), Body),
+        Body = (Goal1; Goal2), 
+        inference(Goal1, Prob1),
+        inference(Goal2, Prob2),
+        ProbRes is PRet*(Prob1 + Prob2 - Prob1*Prob2)
+    ; rule_rec(Rule, ProbRes), !). % cut guarantees single rule_rec call for current Rule; otherwise called again in following case
+
+inference(Rule, ProbRes) :- % case 'single predicate body'
+    ( Rule \= (Goal1, Goal2), Rule \= (Goal1; Goal2) % check: Rule not compound
+    -> clause((PRet :: Rule), Body),
+        ( Body = true
+        -> fail, !
+        ; Body \= (Goal1, Goal2), % preventing compound case from unifying with this more general case
+            Body \= (Goal1; Goal2), % preventing compound case from unifying with this more general case
+            Body = Goal,
+            inference(Goal, Prob),
+            ProbRes is PRet*Prob)
+    ; rule_rec(Rule, ProbRes), !). % cut guarantees single rule_rec call for current Rule; perhaps not necessary, but symmetric to above cases
+
+rule_rec((Goal1, Goal2), ProbRes) :-
+    inference(Goal1, Prob1),
+    inference(Goal2, Prob2),
+    ProbRes is Prob1*Prob2.
+
+rule_rec((Goal1; Goal2), ProbRes) :-
+    inference(Goal1, Prob1),
+    inference(Goal2, Prob2),
+    ProbRes is (Prob1 + Prob2 - Prob1*Prob2).
 
 % not yet tested
 
-% ok
+% seem to be all ok
 0.5::roll_dice(2).
 
+0.5::s(X) :- q(X).
+
+0.4::t(X) :- q(X); r(X).
+
+0.2::t(X) :- q(X), r(Y).
+
+0.7 :: u(X) :- q(X), r(X), p(X).
+0.3 :: u(X) :- q(X); r(X); p(X).
+
 0.4 :: q(a).
 0.5 :: q(b).
 0.7 :: q(c).
 
-% ok
-0.5::s(X) :- q(X).
-
-% not ok: not both answers t(a) and t(b) are provided
-0.4::t(X) :- q(X), r(X).
-
 0.3 :: r(a).
 0.7 :: r(b).
+
+0.6 :: p(a).
+0.1 :: p(b).
+0.9 :: p(c).

commit 91ebde25ca6495d6dc84a6040cf790537b977b94
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Thu Aug 10 22:09:08 2023 +0200

    fix duplicate outputs, now 'false'

diff --git a/src/metaintep.pl b/src/metaintep.pl
index 644fd92..d3fded9 100644
--- a/src/metaintep.pl
+++ b/src/metaintep.pl
@@ -6,33 +6,34 @@
 % lesen von probabilities
 :- op(1199,xfx,::).
 
-demo(true, 1). % base case 'Rule = true'
+demo(true, 1) :- !. % base case 'Rule = true'
 
 demo(Rule, Prob) :- % base case 'body of Rule = true', i.e. Rule atomic
     clause(Prob :: Rule, true).
 
 demo(Rule, ProbRes) :- % case 'compounded body, conjunction'
     clause((PRet :: Rule), Body),
-    Body = (Goal1, Goal2), % !, cut needed?, cut operator in correct place? needs to prevent unifying with 'single predicate body' case as well
-    !,
+    Body = (Goal1, Goal2), 
+    !, % cut prevents unifying with 'single predicate body' case as well
     demo(Goal1, Prob1),
     demo(Goal2, Prob2),
     ProbRes is PRet*Prob1*Prob2.
 
 demo(Rule, ProbRes) :- % case 'compounded body, disjunction'
     clause((PRet :: Rule), Body),
-    Body = (Goal1; Goal2), % !, cut needed?, cut operator in correct place? needs to prevent unifying with Body = Goal case as well
-    !,
+    Body = (Goal1; Goal2), 
+    !, % cut prevents unifying with Body = Goal case as well
     demo(Goal1, Prob1),
     demo(Goal2, Prob2),
     ProbRes is PRet*(Prob1 + Prob2 - Prob1*Prob2).
 
 demo(Rule, ProbRes) :- % case 'single predicate body'
     clause((PRet :: Rule), Body),
-    Body = Goal,
-    !,
+    ( Body = true
+    -> fail, !
+    ; Body = Goal,
     demo(Goal, Prob),
-    ProbRes is PRet*Prob.
+    ProbRes is PRet*Prob).
 
 % not yet tested
 
@@ -41,6 +42,7 @@ demo(Rule, ProbRes) :- % case 'single predicate body'
 
 0.4 :: q(a).
 0.5 :: q(b).
+0.7 :: q(c).
 
 % ok
 0.5::s(X) :- q(X).

commit 796f7e2a08c3114d0a70a186985452bcefb9c2de
Merge: 39e06eb 5ab77ef
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Thu Aug 10 21:09:06 2023 +0200

    Merge branch 'master' of gitlab.lrz.de:000000000135D322/plp

commit 5ab77ef93bfafd641db42682b01efd397eaaa0b7
Author: meisterfischy <grbmn@kstn.in>
Date:   Thu Aug 10 19:14:40 2023 +0200

    Cleanup + WIP

diff --git a/src/experiment.pl b/src/experiment.pl
deleted file mode 100644
index 1f62c19..0000000
--- a/src/experiment.pl
+++ /dev/null
@@ -1,31 +0,0 @@
-% lesen von probabilities
-:- op(1199,xfx,::).
-
-demo((Prob :: Head) :- Body) :-
-    demo((Prob :: Head) :- Body, 1).
-
-demo(Prob :: Rule) :-
-    demo((Prob :: Rule) :- true, 1).
-
-demo(Prob :: true, Akk).
-
-demo((Prob :: Head) :- Body, Akk) :-
-    Akk1 is Akk * Prob,
-
-    %Rule =.. [Head, Body],
-    % :-(Prob::Rule, Body),
-    clause(Prob :: Head, Body),
-
-    get_prob(Body, P),
-    demo(P :: Body, Akk1).
-
-get_prob(true, 1) :- !.
-get_prob(B, PRet) :-
-    PRet :: B.
-
-% ok
-0.5::roll_dice(2).
-
-% noch nicht ok
-0.5::s(X) :- q(X).
-0.4::q(a).
diff --git a/src/metaintep.pl b/src/metaintep.pl
new file mode 100644
index 0000000..644fd92
--- /dev/null
+++ b/src/metaintep.pl
@@ -0,0 +1,52 @@
+% vim: filetype=prolog
+
+
+
+
+% lesen von probabilities
+:- op(1199,xfx,::).
+
+demo(true, 1). % base case 'Rule = true'
+
+demo(Rule, Prob) :- % base case 'body of Rule = true', i.e. Rule atomic
+    clause(Prob :: Rule, true).
+
+demo(Rule, ProbRes) :- % case 'compounded body, conjunction'
+    clause((PRet :: Rule), Body),
+    Body = (Goal1, Goal2), % !, cut needed?, cut operator in correct place? needs to prevent unifying with 'single predicate body' case as well
+    !,
+    demo(Goal1, Prob1),
+    demo(Goal2, Prob2),
+    ProbRes is PRet*Prob1*Prob2.
+
+demo(Rule, ProbRes) :- % case 'compounded body, disjunction'
+    clause((PRet :: Rule), Body),
+    Body = (Goal1; Goal2), % !, cut needed?, cut operator in correct place? needs to prevent unifying with Body = Goal case as well
+    !,
+    demo(Goal1, Prob1),
+    demo(Goal2, Prob2),
+    ProbRes is PRet*(Prob1 + Prob2 - Prob1*Prob2).
+
+demo(Rule, ProbRes) :- % case 'single predicate body'
+    clause((PRet :: Rule), Body),
+    Body = Goal,
+    !,
+    demo(Goal, Prob),
+    ProbRes is PRet*Prob.
+
+% not yet tested
+
+% ok
+0.5::roll_dice(2).
+
+0.4 :: q(a).
+0.5 :: q(b).
+
+% ok
+0.5::s(X) :- q(X).
+
+% not ok: not both answers t(a) and t(b) are provided
+0.4::t(X) :- q(X), r(X).
+
+0.3 :: r(a).
+0.7 :: r(b).
diff --git a/src/sampling.pl b/src/sampling.pl
index 617a2dd..68eae69 100644
--- a/src/sampling.pl
+++ b/src/sampling.pl
@@ -1,2 +1,34 @@
 % vim: filetype=prolog
 
+:- op(601, xfx, <--).
+:- op(600, xfx, ::).
+
+sampling([]).
+sampling([LAtom|Atoms]) :-
+    findall(Prob :: Body, Prob :: LAtom <-- Body, TempSubs),
+    transform_probabilities(TempSubs, Subs),
+    last(Subs, ProbWeight),
+    !,
+    % Use clause?
+    bagof(Prob :: Body, Prob :: LAtom <-- Body, SubCandidate),
+
+
+    select_sub(Subs, Rand, 0, Sub),
+    append(Sub,Atoms,NewAtoms),
+    sampling(NewAtoms).
+
+select_sub([LProb :: LSub|Subs], Rand, Akk, Sub) :-
+    ChoiceValue is LProb + Akk,
+    (ChoiceValue >= Rand
+        -> Sub = LSub
+        ; select_sub(Subs, Rand, ChoiceValue, Sub)).
+
+transform_probabilities([], []).
+transform_probabilities([P::B], [P::B]).
+transform_probabilities([P1::B1,P2::B2|B], L) :-
+    TransfromedProb is P1 + P2,
+    transform_probabilities([TransfromedProb:B2|B], TempL),
+    L = [P1::B1|TempL].
+
+0.5 :: q(a) <-- [].
+0.5 :: q(b) <-- [].

commit 203e1d2d5cfe2285c8b4ee09c72da2078d6ed101
Author: mxs <mxs@dismail.de>
Date:   Thu Aug 10 19:13:05 2023 +0200

    add test case from the chapter

diff --git a/src/stupidgame.pl b/src/stupidgame.pl
new file mode 100644
index 0000000..0eeb6e9
--- /dev/null
+++ b/src/stupidgame.pl
@@ -0,0 +1,21 @@
+play(State) :- stop(State,State).
+play(State) :-
+    pay_entrance(State,State1),
+    dice_reward(State1,State2),
+    play(State2).
+
+stop([Player,Banker],_) :-
+    Player1 is Player,
+    Banker1 is Banker,
+    write('Player = '), write(Player1),
+    write('Banker = '), write(Banker1).
+pay_entrance([Player,Banker],[Player-4,Banker+4]).
+dice_reward([Player,Banker],[Player+D,Banker-D]) :- roll_dice(D).
+
+1/6::roll_dice(1).
+1/6::roll_dice(1).
+1/6::roll_dice(2).
+1/6::roll_dice(3).
+1/6::roll_dice(4).
+1/6::roll_dice(5).
+1/6::roll_dice(6).

commit 39e06eb296e7ca96c90e2050650f71bdcbd8a6cf
Merge: 286aaf2 b70fdd0
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Tue Aug 8 08:32:46 2023 +0200

    Merge branch 'master' of gitlab.lrz.de:000000000135D322/plp

commit 286aaf29aa99c785674b33671dcb9705a6d41ef0
Author: unknown <R.Schwank@campus.lmu.de>
Date:   Tue Aug 8 08:32:27 2023 +0200

    comments to cussens paper

diff --git a/cussens.pdf b/cussens.pdf
index 35c954b..b84821f 100644
Binary files a/cussens.pdf and b/cussens.pdf differ
diff --git a/project_topics.txt b/project_topics.txt
new file mode 100644
index 0000000..0ba3fee
--- /dev/null
+++ b/project_topics.txt
@@ -0,0 +1,31 @@
+A very brief annotated list of topic suggestions:
+
+Inference:
+- First-Order weighted model counting [Lecture in 3 weeks time]
+	- counting satisfying assignments to sentences in FOL
+	- every model receives weight --> sum over all
+	- decoupling logical/symbolic representation from statistical/numeric representation encapsulated in weight function
+- Variable Elimination + Compilation to Bayesian networks [Ask me]
+  [Google "Bayesian Networks" and "Variable Elimination"]
+	- directed acyclic graph to represent variables + their conditional dependencies
+	- application: predicting likelihood of causes for given event
+	- \forall nodes: probability function: parent variables as inputs, probability of current node as output
+	- mechanism to automatically apply Bayes' theorem to complex problems
+	- factor f of variables V: relation between each instantiation v of variables to non-negative number: f(x)
+	- operations include variable summation, factor multiplication
+	- most common query: p(X|E=e), i.e. E is observed taking value e; algorithm to compute this probability is called variable elimination
+	- finding best order of elimination: NP-hard problem
+- Compilation to C programs [Kazemi and Poole: Knowledge Compilation for Lifted Probabilistic Inference -- Compiling to a Low-Level Language]
+
+Learning:
+- Parameter learning [Google "Parameter learning" "probabilistic logic programs"]
+	- sounds like reimplementing existing algorithm
+- Rule induction [Cropper, Inductive Logic Programming at 30]
+	- learning relations instead of functions
+	- data efficiency: drawing hypotheses from small numbers of examples
+	- learning with complex relational information; supporting lifelong and transfer learning
+	- top-down or bottom-up approaches, i.e. specialising a general hypothesis or generalising examples
+	- meta-level: programme reasoning about programmes; delegating search
+
+Sampling techniques [Riguzzi: MCINTYRE -- A Monte Carlo system for probabilistic logic programming
+]

commit b70fdd0d94a67428d4752affae8324b3a4b47eae
Author: mxs <mxs@dismail.de>
Date:   Mon Aug 7 18:25:27 2023 +0200

    wip: rules mit wahrscheinlichkeiten.
    
    problem: desktrukturierung zusammengesetzer clauses wie???

diff --git a/src/experiment.pl b/src/experiment.pl
index dc970e1..1f62c19 100644
--- a/src/experiment.pl
+++ b/src/experiment.pl
@@ -1,17 +1,21 @@
 % lesen von probabilities
 :- op(1199,xfx,::).
 
-demo(Prob :: :-(Head,Body)) :-
-    demo(Prob :: :-(Head,Body), 1).
+demo((Prob :: Head) :- Body) :-
+    demo((Prob :: Head) :- Body, 1).
 
 demo(Prob :: Rule) :-
-    demo(Prob :: :-(Rule,true), 1).
+    demo((Prob :: Rule) :- true, 1).
 
 demo(Prob :: true, Akk).
 
-demo(Prob :: :-(Head,Body), Akk) :-
+demo((Prob :: Head) :- Body, Akk) :-
     Akk1 is Akk * Prob,
+
+    %Rule =.. [Head, Body],
+    % :-(Prob::Rule, Body),
     clause(Prob :: Head, Body),
+
     get_prob(Body, P),
     demo(P :: Body, Akk1).
 

commit 0f29bb8627e89d7f9fd9dba49e4add67d58c2d0d
Author: mxs <mxs@dismail.de>
Date:   Mon Aug 7 17:48:03 2023 +0200

    lesen von ungeschachtelten probabilities

diff --git a/src/experiment.pl b/src/experiment.pl
new file mode 100644
index 0000000..dc970e1
--- /dev/null
+++ b/src/experiment.pl
@@ -0,0 +1,27 @@
+% lesen von probabilities
+:- op(1199,xfx,::).
+
+demo(Prob :: :-(Head,Body)) :-
+    demo(Prob :: :-(Head,Body), 1).
+
+demo(Prob :: Rule) :-
+    demo(Prob :: :-(Rule,true), 1).
+
+demo(Prob :: true, Akk).
+
+demo(Prob :: :-(Head,Body), Akk) :-
+    Akk1 is Akk * Prob,
+    clause(Prob :: Head, Body),
+    get_prob(Body, P),
+    demo(P :: Body, Akk1).
+
+get_prob(true, 1) :- !.
+get_prob(B, PRet) :-
+    PRet :: B.
+
+% ok
+0.5::roll_dice(2).
+
+% noch nicht ok
+0.5::s(X) :- q(X).
+0.4::q(a).

commit 7ba450e51ca59d0f1f014de5155b34838210b84b
Author: meisterfischy <grbmn@kstn.in>
Date:   Sun Jul 23 14:36:51 2023 +0200

    restructuring and renaming

diff --git a/cussens-parameter.pdf b/material/Cussens - Parameter Estimation.pdf
similarity index 100%
rename from cussens-parameter.pdf
rename to material/Cussens - Parameter Estimation.pdf
diff --git a/cussens.pdf b/material/Cussens - Sampling and Inference.pdf
similarity index 100%
rename from cussens.pdf
rename to material/Cussens - Sampling and Inference.pdf
diff --git a/Getoor,Taskar-Introduction_to_Statistical_Relational_Learning(2007).pdf b/material/Getoor,Taskar - Introduction to Statistical Relational Learning.pdf
similarity index 100%
rename from Getoor,Taskar-Introduction_to_Statistical_Relational_Learning(2007).pdf
rename to material/Getoor,Taskar - Introduction to Statistical Relational Learning.pdf
diff --git a/Slides-8-Semantics.pdf b/material/Letcure - SLPs.pdf
similarity index 100%
rename from Slides-8-Semantics.pdf
rename to material/Letcure - SLPs.pdf
diff --git a/src/sampling.pl b/src/sampling.pl
new file mode 100644
index 0000000..617a2dd
--- /dev/null
+++ b/src/sampling.pl
@@ -0,0 +1,2 @@
+% vim: filetype=prolog
+

commit a7fdb00253c7d95ff55abeb95b7b6f845041003b
Author: mxs <mxs@dismail.de>
Date:   Thu Jul 6 14:50:33 2023 +0200

    more ffi links

diff --git a/task.txt b/task.txt
index 21140e9..246daa0 100644
--- a/task.txt
+++ b/task.txt
@@ -15,4 +15,8 @@ max:
 
 implementation:
 berechnungen können alle in ffi sein (c/c++/rust), core logic in prolog
-    ffi: https://github.com/k3ut0i/swipl-ffi-examples
+    ffi:
+        https://github.com/k3ut0i/swipl-ffi-examples
+        https://www.swi-prolog.org/pldoc/man?section=shlib
+        https://www.swi-prolog.org/pldoc/man?section=foreign-read-list
+        https://www.swi-prolog.org/pldoc/man?section=foreign-unify

commit 8352712102222be2716ed0bd29dbfe1f58bb8014
Author: mxs <mxs@dismail.de>
Date:   Thu Jun 29 15:41:23 2023 +0200

    ffi link

diff --git a/task.txt b/task.txt
index 65beaf9..21140e9 100644
--- a/task.txt
+++ b/task.txt
@@ -15,3 +15,4 @@ max:
 
 implementation:
 berechnungen können alle in ffi sein (c/c++/rust), core logic in prolog
+    ffi: https://github.com/k3ut0i/swipl-ffi-examples

commit dc8e0aea78d255e5f0ad8418b72fcf27b7ea58dd
Author: mxs <mxs@dismail.de>
Date:   Thu Jun 29 15:25:05 2023 +0200

    clarifications + more material

diff --git a/Slides-8-Semantics.pdf b/Slides-8-Semantics.pdf
new file mode 100644
index 0000000..a8e3bce
Binary files /dev/null and b/Slides-8-Semantics.pdf differ
diff --git a/cussens-parameter.pdf b/cussens-parameter.pdf
new file mode 100644
index 0000000..e8d54b1
Binary files /dev/null and b/cussens-parameter.pdf differ
diff --git a/task.txt b/task.txt
index 879eb1b..65beaf9 100644
--- a/task.txt
+++ b/task.txt
@@ -3,10 +3,15 @@ min:
         either meta- or via AST (parse with definite clause grammar)
         invent syntax (or use the one from ex. sheets)
         + should be able to compute basic probabilities
-        + sampling for a Stochastic Logic Program (generating worlds)
+        + sampling for a Stochastic Logic Program (generating bindings for the query var.)
 max:
     * implement parameter learning
-        possibly efficiently (inference + sampling)
+        parameter estimation in SLP (from cussens-parameter paper)
+        for this: efficient inference
+        + sampling
+            algorithms: from cussens paper
     * something to aid programmer in meeting requirements
-        + all clauses add to 1
-    * algorithms: from cussens paper
+        all clauses add to < 1 für jede mögliche belegung
+
+implementation:
+berechnungen können alle in ffi sein (c/c++/rust), core logic in prolog

commit 65a2f2b368ec5fe8e78b61042bd3bfb502da5053
Author: mxs <mxs@dismail.de>
Date:   Thu Jun 29 14:44:13 2023 +0200

    upload cussens paper

diff --git a/cussens.pdf b/cussens.pdf
new file mode 100644
index 0000000..35c954b
Binary files /dev/null and b/cussens.pdf differ
diff --git a/task.txt b/task.txt
index d53fac3..879eb1b 100644
--- a/task.txt
+++ b/task.txt
@@ -9,4 +9,4 @@ max:
         possibly efficiently (inference + sampling)
     * something to aid programmer in meeting requirements
         + all clauses add to 1
-    * algorithms: from Stephen Muggleton paper
+    * algorithms: from cussens paper

commit 8314fd4abb06c7019d0b9e73b13e21a6729723f9
Author: mxs <mxs@dismail.de>
Date:   Thu Jun 29 14:41:06 2023 +0200

    initial commit

diff --git a/Getoor,Taskar-Introduction_to_Statistical_Relational_Learning(2007).pdf b/Getoor,Taskar-Introduction_to_Statistical_Relational_Learning(2007).pdf
new file mode 100644
index 0000000..d0a5140
Binary files /dev/null and b/Getoor,Taskar-Introduction_to_Statistical_Relational_Learning(2007).pdf differ
diff --git a/task.txt b/task.txt
new file mode 100644
index 0000000..d53fac3
--- /dev/null
+++ b/task.txt
@@ -0,0 +1,12 @@
+min:
+    * working interpreter for Stochastic Logic Programs, written in prolog
+        either meta- or via AST (parse with definite clause grammar)
+        invent syntax (or use the one from ex. sheets)
+        + should be able to compute basic probabilities
+        + sampling for a Stochastic Logic Program (generating worlds)
+max:
+    * implement parameter learning
+        possibly efficiently (inference + sampling)
+    * something to aid programmer in meeting requirements
+        + all clauses add to 1
+    * algorithms: from Stephen Muggleton paper
